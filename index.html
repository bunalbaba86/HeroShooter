<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Kryptomon Battle Arena</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>

<body>
  <!-- Start Screen -->
  <div id="start-screen" class="screen">
    <div class="start-container">
      <h1>üêæ Kryptomon Battle Arena</h1>
      <p class="subtitle">Epic NFT Battles Await!</p>
      <input type="text" id="playerName" placeholder="Enter your name" maxlength="20" />
      <button id="start-btn" onclick="startGame()">‚öîÔ∏è Start Battle</button>
      <div class="features">
        <div>üéØ Defeat 3 enemy Kryptomon</div>
        <div>‚ö° Real-time multiplayer</div>
        <div>üéÆ Strategic combat</div>
      </div>
    </div>
  </div>

  <!-- Waiting Screen -->
  <div id="waiting-screen" class="screen hidden">
    <div class="waiting-container">
      <h2>üîç Finding Opponent</h2>
      <div class="spinner"></div>
      <div id="waiting-message">Searching for worthy opponent...</div>
      <div id="players-count">Players online: 0</div>
      <button onclick="cancelSearch()" style="margin-top: 20px; padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer;">Cancel Search</button>
    </div>
  </div>

  <!-- Game Screen -->
  <div id="game-screen" class="screen hidden">
    <!-- Game Header -->
    <div class="game-header">
      <div id="status" class="status">Waiting...</div>
    </div>

    <!-- Main Battle Area -->
    <div class="battle-arena">
      <!-- Enemy Area -->
      <div class="enemy-area">
        <div class="enemy-stats">
          <div class="stat-bar">
            <div class="hp-bar">
              <div class="hp-fill"></div>
              <span class="hp-text">100/100</span>
            </div>
            <div class="mp-bar">
              <div class="mp-fill"></div>
              <span class="mp-text">0/100</span>
            </div>
          </div>
        </div>
        <div class="kryptomon enemy">
          <img src="kryptomon1.png" alt="Enemy Kryptomon" />
        </div>
      </div>

      <!-- VS Indicator -->
      <div class="vs-indicator">‚öîÔ∏è VS ‚öîÔ∏è</div>

      <!-- Your Area -->
      <div class="your-area">
        <div class="kryptomon yours">
          <img src="kryptomon1.png" alt="Your Kryptomon" />
        </div>
        <div class="your-stats">
          <div class="stat-bar">
            <div class="hp-bar">
              <div class="hp-fill"></div>
              <span class="hp-text">100/100</span>
            </div>
            <div class="mp-bar">
              <div class="mp-fill"></div>
              <span class="mp-text">0/100</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Battle Controls -->
    <div class="battle-controls">
      <button id="attack-btn" class="control-btn attack" onclick="performBattleMove('attack')">
        <span>‚öîÔ∏è Attack</span>
      </button>
      <button id="defend-btn" class="control-btn defend" onclick="performBattleMove('defend')">
        <span>üõ°Ô∏è Defend</span>
      </button>
      <button id="skill-btn" class="control-btn skill" onclick="performBattleMove('skill')">
        <span>‚ú® Skill (2 MP)</span>
      </button>
      <button id="ultimate-btn" class="control-btn ultimate" onclick="performBattleMove('ultimate')">
        <span>üí• Ultimate (6 MP)</span>
      </button>
    </div>
  </div>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    height: 100vh;
    overflow: hidden;
    position: fixed;
    width: 100%;
    -webkit-font-smoothing: antialiased;
  }

  /* Connection Status */
  .connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    z-index: 1000;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }

  .connection-status.connecting {
    background: rgba(52, 152, 219, 0.9);
    animation: pulse 1.5s infinite;
  }

  .connection-status.connected {
    background: rgba(46, 204, 113, 0.9);
  }

  .connection-status.disconnected {
    background: rgba(231, 76, 60, 0.9);
    animation: shake 0.5s ease-in-out;
  }

  .connection-status.reconnecting {
    background: rgba(241, 196, 15, 0.9);
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.05); }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }

  .screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    padding: 20px;
    transition: opacity 0.3s ease;
  }

  .hidden {
    display: none !important;
  }

  /* Start Screen */
  #start-screen {
    background: rgba(0,0,0,0.95);
    text-align: center;
  }

  #start-screen h1 {
    font-size: clamp(2rem, 5vw, 3rem);
    margin-bottom: 20px;
    color: #FFD700;
    text-shadow: 0 0 20px rgba(255,215,0,0.5);
    animation: glow 2s ease-in-out infinite alternate;
  }

  @keyframes glow {
    from { text-shadow: 0 0 20px rgba(255,215,0,0.5); }
    to { text-shadow: 0 0 30px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.3); }
  }

  #start-screen input {
    padding: 15px;
    font-size: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 25px;
    margin: 10px 0;
    width: 90%;
    max-width: 300px;
    text-align: center;
    background: rgba(255,255,255,0.1);
    color: white;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }

  #start-screen input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
  }

  #start-screen input::placeholder {
    color: rgba(255,255,255,0.7);
  }

  #start-screen button {
    padding: 15px 30px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    border-radius: 25px;
    margin: 10px;
    cursor: pointer;
    width: 90%;
    max-width: 300px;
    transition: all 0.3s ease;
    background: linear-gradient(135deg, #2ecc71, #27ae60);
    color: white;
    backdrop-filter: blur(10px);
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  #start-screen button:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(46, 204, 113, 0.3);
  }

  #start-screen button:active {
    transform: translateY(0);
  }

  .subtitle {
    font-size: 1.2rem;
    margin-bottom: 30px;
    opacity: 0.8;
  }

  .features {
    margin-top: 30px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    opacity: 0.7;
  }

  .features div {
    font-size: 0.9rem;
  }

  /* Waiting Screen */
  #waiting-screen {
    background: rgba(0,0,0,0.9);
    text-align: center;
  }

  .waiting-container h2 {
    font-size: 2rem;
    margin-bottom: 30px;
    color: #3498db;
  }

  .spinner {
    border: 4px solid rgba(255,255,255,0.3);
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  #waiting-message, #players-count {
    font-size: 1.1rem;
    margin: 15px 0;
    opacity: 0.8;
  }

  /* Game Screen */
  #game-screen {
    background: rgba(0,0,0,0.9);
    padding: 10px;
    justify-content: flex-start;
    overflow-y: auto;
  }

  .game-header {
    width: 100%;
    text-align: center;
    margin-bottom: 20px;
  }

  .status {
    font-size: 1.5rem;
    font-weight: bold;
    color: #f39c12;
    text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
  }

  /* Battle Arena */
  .battle-arena {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    height: 50vh;
    margin: 20px 0;
    width: 100%;
  }

  .enemy-area, .your-area {
    display: flex;
    align-items: center;
    gap: 20px;
    width: 100%;
    justify-content: center;
  }

  .kryptomon img {
    width: 120px;
    height: 120px;
    object-fit: contain;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
    transition: all 0.3s ease;
  }

  .kryptomon.attacking img {
    animation: attack 0.5s ease-in-out;
  }

  .kryptomon.defending img {
    animation: defend 0.5s ease-in-out;
  }

  @keyframes attack {
    0%, 100% { transform: translateX(0); }
    50% { transform: translateX(10px) scale(1.1); }
  }

  @keyframes defend {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); filter: brightness(1.3); }
  }

  .vs-indicator {
    font-size: 1.5rem;
    font-weight: bold;
    color: #e74c3c;
    text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
    margin: 10px 0;
  }

  /* Stat Bars */
  .stat-bar {
    display: flex;
    flex-direction: column;
    gap: 5px;
    min-width: 120px;
  }

  .hp-bar, .mp-bar {
    position: relative;
    height: 20px;
    background: rgba(255,255,255,0.2);
    border-radius: 10px;
    overflow: hidden;
  }

  .hp-fill {
    height: 100%;
    background: linear-gradient(90deg, #e74c3c, #c0392b);
    width: 100%;
    transition: width 0.5s ease;
  }

  .mp-fill {
    height: 100%;
    background: linear-gradient(90deg, #3498db, #2980b9);
    width: 0%;
    transition: width 0.5s ease;
  }

  .hp-text, .mp-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
  }

  /* Battle Controls */
  .battle-controls {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 20px;
    width: 100%;
    max-width: 400px;
  }

  .control-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    padding: 15px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 15px;
    background: rgba(255,255,255,0.1);
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    font-weight: bold;
  }

  .control-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }

  .control-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .control-btn.attack:hover:not(:disabled) {
    border-color: #e74c3c;
    background: rgba(231, 76, 60, 0.2);
  }

  .control-btn.defend:hover:not(:disabled) {
    border-color: #3498db;
    background: rgba(52, 152, 219, 0.2);
  }

  .control-btn.skill:hover:not(:disabled) {
    border-color: #9b59b6;
    background: rgba(155, 89, 182, 0.2);
  }

  .control-btn.ultimate:hover:not(:disabled) {
    border-color: #f39c12;
    background: rgba(243, 156, 18, 0.2);
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .battle-controls {
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    
    .control-btn {
      padding: 10px;
      font-size: 14px;
    }
    
    .kryptomon img {
      width: 100px;
      height: 100px;
    }
  }
</style>

<script>
// Enhanced Telegram WebApp integration
const tg = window.Telegram?.WebApp;
const isTelegramWebApp = !!tg;

// Global game state with enhanced management
const gameState = {
  connected: false,
  socket: null,
  inGame: false,
  gameData: null,
  yourIndex: null,
  yourTurn: false,
  playerName: 'Anonymous',
  telegramUserId: null,
  connectionAttempts: 0,
  lastConnectionError: null,
  reconnectTimeout: null,
  gameBackup: null
};

// Enhanced connection status tracking
const connectionStatus = {
  element: null,
  lastUpdate: Date.now(),
  retryCount: 0,
  maxRetries: 5
};

if (tg) {
  console.log('üì± Telegram WebApp detected');
  tg.ready();
  tg.expand();
  
  // Get user info from Telegram
  const user = tg.initDataUnsafe?.user;
  if (user) {
    gameState.playerName = user.first_name || user.username || 'Player';
    gameState.telegramUserId = user.id;
    console.log('üë§ Telegram user:', gameState.playerName);
  }
  
  // Enhanced haptic feedback
  function hapticFeedback(type = 'medium') {
    try {
      if (tg.HapticFeedback) {
        switch(type) {
          case 'light':
            tg.HapticFeedback.impactOccurred('light');
            break;
          case 'medium':
            tg.HapticFeedback.impactOccurred('medium');
            break;
          case 'heavy':
          case 'error':
            tg.HapticFeedback.impactOccurred('heavy');
            break;
          case 'success':
            tg.HapticFeedback.notificationOccurred('success');
            break;
          case 'warning':
            tg.HapticFeedback.notificationOccurred('warning');
            break;
        }
      }
    } catch (error) {
      console.error('Haptic feedback error:', error);
    }
  }
} else {
  // Fallback haptic function for non-Telegram
  function hapticFeedback(type = 'medium') {
    if (navigator.vibrate) {
      switch(type) {
        case 'light':
          navigator.vibrate(50);
          break;
        case 'medium':
          navigator.vibrate(100);
          break;
        case 'heavy':
        case 'error':
          navigator.vibrate([100, 50, 100]);
          break;
        case 'success':
          navigator.vibrate([50, 50, 50]);
          break;
      }
    }
  }
}

// Screen management function
function showScreen(screenId) {
  console.log('üñ•Ô∏è Showing screen:', screenId);
  
  // Hide all screens
  const screens = document.querySelectorAll('.screen');
  screens.forEach(screen => {
    screen.classList.add('hidden');
  });
  
  // Show target screen
  const targetScreen = document.getElementById(screenId);
  if (targetScreen) {
    targetScreen.classList.remove('hidden');
    console.log('‚úÖ Screen shown:', screenId);
  } else {
    console.error('‚ùå Screen not found:', screenId);
  }
}

// Enhanced connection management
function updateConnectionStatus(status) {
  let statusElement = document.getElementById('connection-status');
  if (!statusElement) {
    // Create status element if it doesn't exist
    statusElement = document.createElement('div');
    statusElement.id = 'connection-status';
    statusElement.className = 'connection-status';
    document.body.appendChild(statusElement);
  }
  
  const now = Date.now();
  connectionStatus.lastUpdate = now;
  
  switch(status) {
    case 'connecting':
      statusElement.textContent = 'üîÑ Connecting...';
      statusElement.className = 'connection-status connecting';
      statusElement.style.display = 'block';
      break;
    case 'connected':
      statusElement.textContent = '‚úÖ Connected';
      statusElement.className = 'connection-status connected';
      statusElement.style.display = 'block';
      connectionStatus.retryCount = 0;
      // Hide after 2 seconds
      setTimeout(() => {
        statusElement.style.display = 'none';
      }, 2000);
      break;
    case 'disconnected':
      statusElement.textContent = '‚ùå Disconnected';
      statusElement.className = 'connection-status disconnected';
      statusElement.style.display = 'block';
      break;
    case 'reconnecting':
      statusElement.textContent = `üîÑ Reconnecting... (${connectionStatus.retryCount}/${connectionStatus.maxRetries})`;
      statusElement.className = 'connection-status reconnecting';
      statusElement.style.display = 'block';
      break;
  }
}

// Enhanced connection with retry logic and fallback
function connectToServer(retryCount = 0) {
  if (retryCount >= connectionStatus.maxRetries) {
    updateConnectionStatus('disconnected');
    if (tg?.showAlert) {
      tg.showAlert('Unable to connect to server. Please check your internet connection and try again.');
    } else {
      alert('Unable to connect to server. Please check your internet connection and try again.');
    }
    return;
  }

  updateConnectionStatus(retryCount === 0 ? 'connecting' : 'reconnecting');
  connectionStatus.retryCount = retryCount;
  
  // Use same domain (Vercel)
  const serverUrl = window.location.origin;
  console.log(`üîå Connecting to server (attempt ${retryCount + 1}):`, serverUrl);
  
  // Clear any existing connection
  if (gameState.socket) {
    gameState.socket.disconnect();
    gameState.socket = null;
  }

  gameState.socket = io(serverUrl, {
    withCredentials: true,
    timeout: 30000,
    transports: ['polling', 'websocket'], // Polling first for stability
    forceNew: true,
    reconnection: true,
    reconnectionAttempts: 3,
    reconnectionDelay: 2000,
    reconnectionDelayMax: 10000,
    maxReconnectionAttempts: 3,
    pingTimeout: 60000,
    pingInterval: 25000
  });

  // Enhanced game event handlers
  setupGameEventHandlers();
}

// Enhanced game event handlers
function setupGameEventHandlers() {
  if (!gameState.socket) return;

  // Clear existing listeners to prevent duplicates
  gameState.socket.removeAllListeners();

  // Connection events
  gameState.socket.on('connect', () => {
    console.log('‚úÖ Connected to server');
    gameState.connected = true;
    gameState.connectionAttempts = 0;
    updateConnectionStatus('connected');
    
    // Clear any reconnect timeout
    if (gameState.reconnectTimeout) {
      clearTimeout(gameState.reconnectTimeout);
      gameState.reconnectTimeout = null;
    }
    
    // ‚≠ê OTOMATIK OYUNA KATIL - BU √áOK √ñNEMLƒ∞!
    console.log('üéÆ Auto-joining game...');
    gameState.socket.emit('joinGame', {
      username: gameState.playerName,
      telegramUserId: gameState.telegramUserId,
      isTelegramUser: isTelegramWebApp
    });
  });

  gameState.socket.on('connect_error', (error) => {
    console.error('‚ùå Connection error:', error);
    gameState.connected = false;
    gameState.lastConnectionError = error;
    
    // Exponential backoff retry
    const delay = Math.min(Math.pow(2, connectionStatus.retryCount) * 1000, 10000);
    console.log(`üîÑ Retrying connection in ${delay}ms...`);
    
    gameState.reconnectTimeout = setTimeout(() => {
      connectToServer(connectionStatus.retryCount + 1);
    }, delay);
  });

  gameState.socket.on('disconnect', (reason) => {
    console.log('‚ùå Disconnected:', reason);
    gameState.connected = false;
    updateConnectionStatus('disconnected');
    
    // Auto-reconnect for certain reasons
    if (reason === 'io server disconnect') {
      if (tg?.showAlert) {
        tg.showAlert('Server disconnected. Please restart the game.');
      }
    } else {
      console.log('üîÑ Attempting auto-reconnect...');
      gameState.reconnectTimeout = setTimeout(() => {
        connectToServer(0);
      }, 3000);
    }
  });

  // GAME EVENT HANDLERS
  
  // ‚≠ê WAITING FOR OPPONENT
  gameState.socket.on('waitingForOpponent', (data) => {
    console.log('‚è≥ Waiting for opponent...', data);
    showScreen('waiting-screen');
    
    const waitingMessage = document.getElementById('waiting-message');
    if (waitingMessage) {
      waitingMessage.textContent = data.message || 'Finding opponent...';
    }
    
    const playersCount = document.getElementById('players-count');
    if (playersCount && data.playersWaiting !== undefined) {
      playersCount.textContent = `Players waiting: ${data.playersWaiting}`;
    }
  });

  // ‚≠ê GAME STARTED - EN √ñNEMLƒ∞ EVENT!
  gameState.socket.on('gameStarted', (data) => {
    console.log('üéÆ Game started!', data);
    console.log('üîç Received data:', JSON.stringify(data, null, 2));
    
    try {
      gameState.inGame = true;
      gameState.gameData = data.gameRoom;
      gameState.yourIndex = data.yourIndex;
      gameState.yourTurn = data.gameRoom.currentTurn === data.yourIndex;
      
      console.log('üë§ Your index:', gameState.yourIndex);
      console.log('üéØ Your turn:', gameState.yourTurn);
      console.log('üéÆ Game room:', data.gameRoom);
      
      // ZORUNLU: Game screen'e ge√ß
      console.log('üñ•Ô∏è Switching to game screen...');
      showScreen('game-screen');
      
      // UI'yi g√ºncelle
      updateUI(data.gameRoom);
      hapticFeedback('success');
      
      // Backup temizle
      localStorage.removeItem('kryptomon_game_backup');
      
      console.log('‚úÖ Game started successfully!');
      
    } catch (error) {
      console.error('‚ùå Game start error:', error);
      if (tg?.showAlert) {
        tg.showAlert('Failed to start game. Please try again.');
      } else {
        alert('Failed to start game. Please try again.');
      }
    }
  });

  // Move result
  gameState.socket.on('moveResult', (data) => {
    console.log('‚öîÔ∏è Move result:', data);
    try {
      gameState.gameData = data.gameRoom;
      gameState.yourTurn = data.gameRoom.currentTurn === gameState.yourIndex;
      
      updateUI(data.gameRoom);
      
    } catch (error) {
      console.error('‚ùå Move result error:', error);
    }
  });

  gameState.socket.on('gameOver', (data) => {
    console.log('üèÅ Game over:', data);
    gameState.inGame = false;
    gameState.gameData = null;
    
    localStorage.removeItem('kryptomon_game_backup');
    
    const isWinner = data.winner === gameState.yourIndex;
    
    if (isWinner) {
      hapticFeedback('success');
      if (tg?.showAlert) {
        tg.showAlert('üèÜ Victory! You defeated all enemy Kryptomon!');
      } else {
        alert('üèÜ Victory! You defeated all enemy Kryptomon!');
      }
    } else {
      hapticFeedback('error');
      if (tg?.showAlert) {
        tg.showAlert('üíÄ Defeat! Your team has fallen!');
      } else {
        alert('üíÄ Defeat! Your team has fallen!');
      }
    }
    
    setTimeout(() => {
      showScreen('start-screen');
    }, 3000);
  });

  gameState.socket.on('error', (error) => {
    console.error('üö® Socket error:', error);
    hapticFeedback('error');
    
    const status = document.getElementById('status');
    if (status && gameState.inGame) {
      status.textContent = '‚ùå ' + (error.message || 'Action failed');
      setTimeout(() => {
        if (gameState.inGame) {
          status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
        }
      }, 3000);
    }
  });
}

// Basic UI update function
function updateUI(gameRoom) {
  console.log('üé® Updating UI with game data:', gameRoom);
  
  if (!gameRoom || gameState.yourIndex === null) return;
  
  try {
    // Update status
    const status = document.getElementById('status');
    if (status) {
      status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
    }
    
    // Update player stats
    const yourData = gameRoom.players[gameState.yourIndex];
    const enemyData = gameRoom.players[1 - gameState.yourIndex];
    
    if (yourData && enemyData) {
      const yourKryptomon = yourData.team[yourData.currentKryptomon];
      const enemyKryptomon = enemyData.team[enemyData.currentKryptomon];
      
      // Update your stats
      const yourHpBar = document.querySelector('.your-stats .hp-fill');
      const yourMpBar = document.querySelector('.your-stats .mp-fill');
      const yourHpText = document.querySelector('.your-stats .hp-text');
      const yourMpText = document.querySelector('.your-stats .mp-text');
      
      if (yourHpBar && yourKryptomon) {
        const hpPercent = (yourKryptomon.hp / yourKryptomon.maxHp) * 100;
        yourHpBar.style.width = hpPercent + '%';
      }
      
      if (yourMpBar && yourKryptomon) {
        const mpPercent = (yourKryptomon.mana / yourKryptomon.maxMana) * 100;
        yourMpBar.style.width = mpPercent + '%';
      }
      
      if (yourHpText && yourKryptomon) {
        yourHpText.textContent = `${yourKryptomon.hp}/${yourKryptomon.maxHp}`;
      }
      
      if (yourMpText && yourKryptomon) {
        yourMpText.textContent = `${yourKryptomon.mana}/${yourKryptomon.maxMana}`;
      }
      
      // Update enemy stats
      const enemyHpBar = document.querySelector('.enemy-stats .hp-fill');
      const enemyMpBar = document.querySelector('.enemy-stats .mp-fill');
      const enemyHpText = document.querySelector('.enemy-stats .hp-text');
      const enemyMpText = document.querySelector('.enemy-stats .mp-text');
      
      if (enemyHpBar && enemyKryptomon) {
        const hpPercent = (enemyKryptomon.hp / enemyKryptomon.maxHp) * 100;
        enemyHpBar.style.width = hpPercent + '%';
      }
      
      if (enemyMpBar && enemyKryptomon) {
        const mpPercent = (enemyKryptomon.mana / enemyKryptomon.maxMana) * 100;
        enemyMpBar.style.width = mpPercent + '%';
      }
      
      if (enemyHpText && enemyKryptomon) {
        enemyHpText.textContent = `${enemyKryptomon.hp}/${enemyKryptomon.maxHp}`;
      }
      
      if (enemyMpText && enemyKryptomon) {
        enemyMpText.textContent = `${enemyKryptomon.mana}/${enemyKryptomon.maxMana}`;
      }
      
      // Update Kryptomon images
      const yourKryptomonImg = document.querySelector('.kryptomon.yours img');
      const enemyKryptomonImg = document.querySelector('.kryptomon.enemy img');
      
      if (yourKryptomonImg && yourKryptomon) {
        yourKryptomonImg.src = `kryptomon${yourKryptomon.sprite}.png`;
      }
      
      if (enemyKryptomonImg && enemyKryptomon) {
        enemyKryptomonImg.src = `kryptomon${enemyKryptomon.sprite}.png`;
      }
      
      // Update button states
      updateButtons();
    }
    
  } catch (error) {
    console.error('‚ùå UI update error:', error);
  }
}

// Update control buttons
function updateButtons() {
  if (!gameState.gameData || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameState.gameData.players[gameState.yourIndex];
    const currentKryptomon = yourData.team[yourData.currentKryptomon];
    
    if (!currentKryptomon) return;
    
    // Update button states
    const attackBtn = document.getElementById('attack-btn');
    const defendBtn = document.getElementById('defend-btn');
    const skillBtn = document.getElementById('skill-btn');
    const ultimateBtn = document.getElementById('ultimate-btn');
    
    // Attack - always available if alive
    if (attackBtn) {
      attackBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive;
    }
    
    // Defend - check cooldown
    if (defendBtn) {
      defendBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || yourData.defendCooldown > 0;
      if (yourData.defendCooldown > 0) {
        defendBtn.querySelector('span').textContent = `üõ°Ô∏è Defend (${yourData.defendCooldown})`;
      } else {
        defendBtn.querySelector('span').textContent = 'üõ°Ô∏è Defend';
      }
    }
    
    // Skill - check mana
    if (skillBtn) {
      skillBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || currentKryptomon.mana < 2;
    }
    
    // Ultimate - check mana and usage
    if (ultimateBtn) {
      ultimateBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || 
                            currentKryptomon.mana < 6 || currentKryptomon.ultimateUsed;
      if (currentKryptomon.ultimateUsed) {
        ultimateBtn.querySelector('span').textContent = 'üí• Ultimate (Used)';
      } else {
        ultimateBtn.querySelector('span').textContent = 'üí• Ultimate (6 MP)';
      }
    }
    
  } catch (error) {
    console.error('‚ùå Button update error:', error);
  }
}

// Battle move function
function performBattleMove(moveType) {
  console.log('‚öîÔ∏è Performing move:', moveType);
  
  if (!gameState.connected || !gameState.socket) {
    hapticFeedback('error');
    return;
  }

  if (!gameState.inGame) {
    hapticFeedback('error');
    return;
  }

  if (!gameState.yourTurn) {
    hapticFeedback('error');
    return;
  }

  try {
    gameState.socket.emit('battleMove', {
      move: moveType
    });
    
    hapticFeedback('medium');
    
  } catch (error) {
    console.error('‚ùå Battle move failed:', error);
    hapticFeedback('error');
  }
}

// Start game function
function startGame() {
  const nameInput = document.getElementById('playerName');
  if (nameInput && nameInput.value.trim()) {
    gameState.playerName = nameInput.value.trim();
  }
  
  console.log('üéÆ Starting game as:', gameState.playerName);
  hapticFeedback('light');
  connectToServer();
}

// Cancel search function
function cancelSearch() {
  console.log('‚ùå Cancelling search...');
  if (gameState.socket) {
    gameState.socket.disconnect();
  }
  showScreen('start-screen');
  hapticFeedback('light');
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
  console.log('üöÄ Page loaded, initializing...');
  showScreen('start-screen');
  
  // Auto-fill Telegram name if available
  if (gameState.playerName !== 'Anonymous') {
    const nameInput = document.getElementById('playerName');
    if (nameInput) {
      nameInput.value = gameState.playerName;
    }
  }
  
  // Auto-start for Telegram users
  if (isTelegramWebApp) {
    setTimeout(() => {
      startGame();
    }, 1000);
  }
});

// Debug functions for testing
window.gameState = gameState;
window.showScreen = showScreen;
window.connectToServer = connectToServer;

</script>

</body>
</html>
