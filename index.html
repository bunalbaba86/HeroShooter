<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Kryptomon Battle Arena</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<script>
// Enhanced Telegram WebApp integration
const tg = window.Telegram?.WebApp;
const isTelegramWebApp = !!tg;

// Global game state with enhanced management
const gameState = {
  connected: false,
  socket: null,
  inGame: false,
  gameData: null,
  yourIndex: null,
  yourTurn: false,
  playerName: 'Anonymous',
  telegramUserId: null,
  connectionAttempts: 0,
  lastConnectionError: null,
  reconnectTimeout: null,
  gameBackup: null
};

// Enhanced connection status tracking
const connectionStatus = {
  element: null,
  lastUpdate: Date.now(),
  retryCount: 0,
  maxRetries: 5
};

if (tg) {
  console.log('üì± Telegram WebApp detected');
  tg.ready();
  tg.expand();
  
  // Get user info from Telegram
  const user = tg.initDataUnsafe?.user;
  if (user) {
    gameState.playerName = user.first_name || user.username || 'Player';
    gameState.telegramUserId = user.id;
    console.log('üë§ Telegram user:', gameState.playerName);
  }
  
  // Enhanced haptic feedback
  function hapticFeedback(type = 'medium') {
    try {
      if (tg.HapticFeedback) {
        switch(type) {
          case 'light':
            tg.HapticFeedback.impactOccurred('light');
            break;
          case 'medium':
            tg.HapticFeedback.impactOccurred('medium');
            break;
          case 'heavy':
          case 'error':
            tg.HapticFeedback.impactOccurred('heavy');
            break;
          case 'success':
            tg.HapticFeedback.notificationOccurred('success');
            break;
          case 'warning':
            tg.HapticFeedback.notificationOccurred('warning');
            break;
        }
      }
    } catch (error) {
      console.error('Haptic feedback error:', error);
    }
  }
  
  // Show main button after game
  function showMainButton(text, callback) {
    try {
      tg.MainButton.text = text;
      tg.MainButton.show();
      tg.MainButton.onClick(callback);
    } catch (error) {
      console.error('Main button error:', error);
    }
  }
} else {
  // Fallback haptic function for non-Telegram
  function hapticFeedback(type = 'medium') {
    if (navigator.vibrate) {
      switch(type) {
        case 'light':
          navigator.vibrate(50);
          break;
        case 'medium':
          navigator.vibrate(100);
          break;
        case 'heavy':
        case 'error':
          navigator.vibrate([100, 50, 100]);
          break;
        case 'success':
          navigator.vibrate([50, 50, 50]);
          break;
      }
    }
  }
  
  function showMainButton() {
    // No-op for non-Telegram
  }
}

// Enhanced connection management
function updateConnectionStatus(status) {
  const statusElement = document.getElementById('connection-status');
  if (!statusElement) return;
  
  const now = Date.now();
  connectionStatus.lastUpdate = now;
  
  switch(status) {
    case 'connecting':
      statusElement.textContent = 'üîÑ Connecting...';
      statusElement.className = 'connection-status connecting';
      break;
    case 'connected':
      statusElement.textContent = '‚úÖ Connected';
      statusElement.className = 'connection-status connected';
      connectionStatus.retryCount = 0;
      // Hide after 2 seconds
      setTimeout(() => {
        statusElement.style.display = 'none';
      }, 2000);
      break;
    case 'disconnected':
      statusElement.textContent = '‚ùå Disconnected';
      statusElement.className = 'connection-status disconnected';
      statusElement.style.display = 'block';
      break;
    case 'reconnecting':
      statusElement.textContent = `üîÑ Reconnecting... (${connectionStatus.retryCount}/${connectionStatus.maxRetries})`;
      statusElement.className = 'connection-status reconnecting';
      statusElement.style.display = 'block';
      break;
  }
}

// Enhanced game state backup/restore
function backupGameState() {
  if (gameState.inGame && gameState.gameData) {
    try {
      const backup = {
        gameData: gameState.gameData,
        yourIndex: gameState.yourIndex,
        playerName: gameState.playerName,
        telegramUserId: gameState.telegramUserId,
        timestamp: Date.now()
      };
      localStorage.setItem('kryptomon_game_backup', JSON.stringify(backup));
      gameState.gameBackup = backup;
      console.log('üíæ Game state backed up');
    } catch (error) {
      console.error('‚ùå Backup failed:', error);
    }
  }
}

function restoreGameState() {
  try {
    const backup = localStorage.getItem('kryptomon_game_backup');
    if (backup) {
      const data = JSON.parse(backup);
      // Only restore if backup is less than 5 minutes old
      if (Date.now() - data.timestamp < 300000) {
        console.log('üîÑ Restoring game state');
        return data;
      } else {
        console.log('‚è∞ Backup too old, discarding');
        localStorage.removeItem('kryptomon_game_backup');
      }
    }
  } catch (error) {
    console.error('‚ùå Restore failed:', error);
    localStorage.removeItem('kryptomon_game_backup');
  }
  return null;
}

// Enhanced connection with retry logic and fallback
function connectToServer(retryCount = 0) {
  if (retryCount >= connectionStatus.maxRetries) {
    updateConnectionStatus('disconnected');
    if (tg?.showAlert) {
      tg.showAlert('Unable to connect to server. Please check your internet connection and try again.');
    } else {
      alert('Unable to connect to server. Please check your internet connection and try again.');
    }
    return;
  }

  updateConnectionStatus(retryCount === 0 ? 'connecting' : 'reconnecting');
  connectionStatus.retryCount = retryCount;
  
  // Use same domain (Vercel)
  const serverUrl = window.location.origin;
  console.log(`üîå Connecting to server (attempt ${retryCount + 1}):`, serverUrl);
  
  // Clear any existing connection
  if (gameState.socket) {
    gameState.socket.disconnect();
    gameState.socket = null;
  }

  gameState.socket = io(serverUrl, {
    withCredentials: true,
    timeout: 30000,
    transports: ['polling', 'websocket'], // Polling first for stability
    forceNew: true,
    reconnection: true,
    reconnectionAttempts: 3,
    reconnectionDelay: 2000,
    reconnectionDelayMax: 10000,
    maxReconnectionAttempts: 3,
    pingTimeout: 60000,
    pingInterval: 25000
  });

  // Connection success
  gameState.socket.on('connect', () => {
    console.log('‚úÖ Connected to server');
    gameState.connected = true;
    gameState.connectionAttempts = 0;
    updateConnectionStatus('connected');
    
    // Clear any reconnect timeout
    if (gameState.reconnectTimeout) {
      clearTimeout(gameState.reconnectTimeout);
      gameState.reconnectTimeout = null;
    }
    
    // Try to restore game state
    const backup = restoreGameState();
    if (backup && !gameState.inGame) {
      console.log('üîÑ Attempting to rejoin game');
      hapticFeedback('light');
    }
    
    // Re-enable UI elements
    enableGameUI();
  });

  // Connection error handling
  gameState.socket.on('connect_error', (error) => {
    console.error('‚ùå Connection error:', error);
    gameState.connected = false;
    gameState.lastConnectionError = error;
    
    // Exponential backoff retry
    const delay = Math.min(Math.pow(2, retryCount) * 1000, 10000);
    console.log(`üîÑ Retrying connection in ${delay}ms...`);
    
    gameState.reconnectTimeout = setTimeout(() => {
      connectToServer(retryCount + 1);
    }, delay);
  });

  // Disconnection handling
  gameState.socket.on('disconnect', (reason) => {
    console.log('‚ùå Disconnected:', reason);
    gameState.connected = false;
    updateConnectionStatus('disconnected');
    
    // Backup current game state
    backupGameState();
    
    // Disable UI elements
    disableGameUI();
    
    // Auto-reconnect for certain reasons
    if (reason === 'io server disconnect') {
      // Server initiated disconnect, don't auto-reconnect
      if (tg?.showAlert) {
        tg.showAlert('Server disconnected. Please restart the game.');
      }
    } else {
      // Client side disconnect, try to reconnect
      console.log('üîÑ Attempting auto-reconnect...');
      gameState.reconnectTimeout = setTimeout(() => {
        connectToServer(0);
      }, 3000);
    }
  });

  // Reconnection events
  gameState.socket.on('reconnect', (attemptNumber) => {
    console.log('‚úÖ Reconnected after', attemptNumber, 'attempts');
    updateConnectionStatus('connected');
    hapticFeedback('success');
    enableGameUI();
  });

  gameState.socket.on('reconnect_error', (error) => {
    console.error('‚ùå Reconnection failed:', error);
  });

  gameState.socket.on('reconnect_failed', () => {
    console.error('‚ùå All reconnection attempts failed');
    updateConnectionStatus('disconnected');
    if (tg?.showAlert) {
      tg.showAlert('Connection lost. Please restart the game.');
    }
  });

  // Game event handlers with enhanced error handling
  setupGameEventHandlers();
}

// UI state management
function enableGameUI() {
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(btn => {
    btn.disabled = false;
    btn.style.opacity = '1';
    btn.style.pointerEvents = 'auto';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'auto';
    slot.style.opacity = '1';
  });
}

function disableGameUI() {
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(btn => {
    btn.disabled = true;
    btn.style.opacity = '0.5';
    btn.style.pointerEvents = 'none';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'none';
    slot.style.opacity = '0.5';
  });
}

// Enhanced game event handlers
function setupGameEventHandlers() {
  if (!gameState.socket) return;

  // Join game response
  gameState.socket.on('waitingForOpponent', () => {
    console.log('‚è≥ Waiting for opponent...');
    showScreen('waiting-screen');
    document.getElementById('waiting-message').textContent = 'Waiting for opponent...';
  });

  // Game started
  gameState.socket.on('gameStarted', (data) => {
    console.log('üéÆ Game started!', data);
    try {
      gameState.inGame = true;
      gameState.gameData = data.gameRoom;
      gameState.yourIndex = data.yourIndex;
      gameState.yourTurn = data.gameRoom.currentTurn === data.yourIndex;
      
      showScreen('game-screen');
      updateUI(data.gameRoom);
      hapticFeedback('success');
      
      // Clear any backup since we have fresh game state
      localStorage.removeItem('kryptomon_game_backup');
      
    } catch (error) {
      console.error('‚ùå Game start error:', error);
      if (tg?.showAlert) {
        tg.showAlert('Failed to start game. Please try again.');
      }
    }
  });

  // Move result
  gameState.socket.on('moveResult', (data) => {
    console.log('‚öîÔ∏è Move result:', data);
    try {
      gameState.gameData = data.gameRoom;
      gameState.yourTurn = data.gameRoom.currentTurn === gameState.yourIndex;
      
      processMoveResult(data.moveResult);
      updateUI(data.gameRoom);
      backupGameState(); // Backup after each move
      
    } catch (error) {
      console.error('‚ùå Move result error:', error);
    }
  });

  // Team switched
  gameState.socket.on('teamSwitched', (data) => {
    console.log('‚úÖ Team switched:', data);
    try {
      if (data.success) {
        gameState.gameData = data.gameRoom;
        updateUI(data.gameRoom);
        
        if (data.playerIndex === gameState.yourIndex) {
          hapticFeedback('success');
          showMessage('‚úÖ Kryptomon switched!', 'success');
        }
        
        updateTeamDisplay();
        backupGameState();
      }
    } catch (error) {
      console.error('‚ùå Team switch error:', error);
    }
  });

  // Game over
  gameState.socket.on('gameOver', (data) => {
    console.log('üèÅ Game over:', data);
    try {
      gameState.inGame = false;
      const isWinner = data.winner === gameState.yourIndex;
      
      hapticFeedback(isWinner ? 'success' : 'error');
      
      const message = isWinner ? 'üèÜ You Won!' : 'üíÄ You Lost!';
      showMessage(message, isWinner ? 'success' : 'error', 5000);
      
      // Clear game backup
      localStorage.removeItem('kryptomon_game_backup');
      
      // Show restart option after delay
      setTimeout(() => {
        if (tg) {
          showMainButton('üéÆ Play Again', () => {
            location.reload();
          });
        } else {
          if (confirm('Game Over! Play again?')) {
            location.reload();
          }
        }
      }, 3000);
      
    } catch (error) {
      console.error('‚ùå Game over error:', error);
    }
  });

  // Opponent disconnected
  gameState.socket.on('opponentDisconnected', (data) => {
    console.log('üíî Opponent disconnected:', data);
    hapticFeedback('warning');
    showMessage('‚ö†Ô∏è Opponent disconnected, waiting for reconnection...', 'warning');
  });

  // Error handling
  gameState.socket.on('error', (error) => {
    console.error('üö® Socket error:', error);
    hapticFeedback('error');
    
    // Show user-friendly error message
    let message = 'Something went wrong';
    if (error.message) {
      if (error.message.includes('turn')) {
        message = 'Not your turn!';
      } else if (error.message.includes('mana')) {
        message = 'Not enough mana!';
      } else if (error.message.includes('cooldown')) {
        message = 'Defend on cooldown!';
      } else if (error.message.includes('ultimate')) {
        message = 'Ultimate already used!';
      } else if (error.message.includes('defeated')) {
        message = 'Cannot switch to defeated Kryptomon!';
      } else {
        message = error.message;
      }
    }
    
    showMessage('‚ùå ' + message, 'error', 3000);
  });

  // Connection quality monitoring
  gameState.socket.on('ping', () => {
    gameState.socket.emit('pong', Date.now());
  });
  
  gameState.socket.on('pong', (timestamp) => {
    const latency = Date.now() - timestamp;
    console.log(`üèì Latency: ${latency}ms`);
    
    // Show latency warning for high ping
    if (latency > 500) {
      showMessage(`‚ö†Ô∏è High latency: ${latency}ms`, 'warning', 2000);
    }
  });
}

// Enhanced message system
function showMessage(message, type = 'info', duration = 3000) {
  const statusElement = document.getElementById('status');
  if (!statusElement) return;
  
  statusElement.textContent = message;
  statusElement.className = `status ${type}`;
  
  // Clear message after duration
  setTimeout(() => {
    if (gameState.inGame) {
      statusElement.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
      statusElement.className = 'status';
    }
  }, duration);
}
</script>

<!-- CSS styles remain the same but with enhanced connection status -->
<style>
  /* Your existing CSS... */
  
  /* Enhanced connection status */
  .connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(0,0,0,0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 12px;
    z-index: 1000;
    backdrop-filter: blur(10px);
    border: 2px solid;
    display: none;
  }
  
  .connection-status.connecting {
    border-color: #f39c12;
    background: rgba(243, 156, 18, 0.2);
  }
  
  .connection-status.connected {
    border-color: #27ae60;
    background: rgba(39, 174, 96, 0.2);
  }
  
  .connection-status.disconnected {
    border-color: #e74c3c;
    background: rgba(231, 76, 60, 0.2);
  }
  
  .connection-status.reconnecting {
    border-color: #3498db;
    background: rgba(52, 152, 219, 0.2);
  }
  
  /* Enhanced status messages */
  .status {
    transition: all 0.3s ease;
  }
  
  .status.success {
    color: #27ae60;
    text-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
  }
  
  .status.error {
    color: #e74c3c;
    text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
  }
  
  .status.warning {
    color: #f39c12;
    text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
  }
  
  /* Rest of your CSS styles... */
</style>
    forceNew: true,
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 2000,
    reconnectionDelayMax: 10000,
    maxReconnectionAttempts: 5,
    randomizationFactor: 0.5
  });

  // Enhanced connection event handlers
  gameState.socket.on('connect', () => {
    console.log('‚úÖ Connected to server');
    gameState.connected = true;
    gameState.connectionAttempts = 0;
    gameState.lastConnectionError = null;
    updateConnectionStatus('connected');
    
    // Clear any pending reconnect timeout
    if (gameState.reconnectTimeout) {
      clearTimeout(gameState.reconnectTimeout);
      gameState.reconnectTimeout = null;
    }
    
    // Restore game state if available
    const backup = restoreGameState();
    if (backup && !gameState.inGame) {
      console.log('üîÑ Attempting to restore game state');
      gameState.socket.emit('rejoinGame', {
        username: backup.playerName,
        telegramUserId: backup.telegramUserId,
        gameData: backup.gameData
      });
    } else if (!gameState.inGame) {
      // Join new game
      gameState.socket.emit('joinGame', {
        username: gameState.playerName,
        telegramUserId: gameState.telegramUserId,
        isTelegramUser: isTelegramWebApp
      });
    }
  });

  gameState.socket.on('disconnect', (reason) => {
    console.log('‚ùå Disconnected from server:', reason);
    gameState.connected = false;
    updateConnectionStatus('disconnected');
    
    // Backup current game state
    backupGameState();
    
    // Disable UI elements
    disableGameControls();
    
    // Show user-friendly message based on reason
    if (reason === 'io server disconnect') {
      // Server initiated disconnect
      if (tg?.showAlert) {
        tg.showAlert('Server disconnected. Please restart the game.');
      }
    } else if (reason === 'transport close' || reason === 'transport error') {
      // Network issues
      if (gameState.inGame) {
        const status = document.getElementById('status');
        if (status) {
          status.textContent = 'üîÑ Connection lost, reconnecting...';
        }
      }
    }
  });

  gameState.socket.on('reconnect', (attemptNumber) => {
    console.log('‚úÖ Reconnected after', attemptNumber, 'attempts');
    gameState.connected = true;
    updateConnectionStatus('connected');
    
    // Re-enable UI elements
    enableGameControls();
    
    if (gameState.inGame) {
      const status = document.getElementById('status');
      if (status) {
        status.textContent = '‚úÖ Reconnected!';
        setTimeout(() => {
          status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
        }, 2000);
      }
    }
    
    hapticFeedback('success');
  });

  gameState.socket.on('reconnect_error', (error) => {
    console.error('‚ùå Reconnection failed:', error);
    gameState.lastConnectionError = error;
  });

  gameState.socket.on('reconnect_failed', () => {
    console.error('‚ùå Reconnection failed completely');
    updateConnectionStatus('disconnected');
    
    if (tg?.showAlert) {
      tg.showAlert('Unable to reconnect. Please restart the game.');
    } else {
      alert('Unable to reconnect. Please restart the game.');
    }
  });

  gameState.socket.on('connect_error', (error) => {
    console.error('‚ùå Connection error:', error);
    gameState.lastConnectionError = error;
    updateConnectionStatus('disconnected');
    
    // Retry with exponential backoff
    if (retryCount < connectionStatus.maxRetries) {
      const delay = Math.min(1000 * Math.pow(2, retryCount), 10000);
      console.log(`üîÑ Retrying connection in ${delay}ms...`);
      
      gameState.reconnectTimeout = setTimeout(() => {
        connectToServer(retryCount + 1);
      }, delay);
    } else {
      if (tg?.showAlert) {
        tg.showAlert('Connection failed! Please check your internet and try again.');
      } else {
        alert('Connection failed! Please check your internet and try again.');
      }
    }
  });

  // Enhanced game event handlers
  gameState.socket.on('waitingForOpponent', () => {
    console.log('‚è≥ Waiting for opponent');
    showScreen('waiting-screen');
  });

  gameState.socket.on('gameStarted', (data) => {
    console.log('üéÆ Game started:', data);
    gameState.inGame = true;
    gameState.gameData = data.gameRoom;
    gameState.yourIndex = data.yourIndex;
    gameState.yourTurn = data.gameRoom.currentTurn === data.yourIndex;
    
    // Clear any backup since we have a new game
    localStorage.removeItem('kryptomon_game_backup');
    
    showScreen('game-screen');
    updateUI(data.gameRoom);
    updateTeamDisplay();
    
    hapticFeedback('success');
  });

  gameState.socket.on('moveResult', (data) => {
    console.log('‚öîÔ∏è Move result:', data);
    gameState.gameData = data.gameRoom;
    gameState.yourTurn = data.gameRoom.currentTurn === gameState.yourIndex;
    
    updateUI(data.gameRoom);
    updateTeamDisplay();
    
    // Handle move animation and effects
    if (data.moveResult.soundEffect) {
      playSound(data.moveResult.soundEffect);
    }
    
    if (data.moveResult.damageInfo) {
      showDamageText(data.moveResult.damageInfo);
    }
    
    // Apply visual effects
    applyMoveAnimation(data.moveResult);
    
    // Backup updated state
    backupGameState();
  });

  gameState.socket.on('teamSwitched', (data) => {
    console.log('‚úÖ Team switched:', data);
    
    if (data.success) {
      gameState.gameData = data.gameRoom;
      updateUI(data.gameRoom);
      updateTeamDisplay();
      
      if (data.playerIndex === gameState.yourIndex) {
        hapticFeedback('success');
        const status = document.getElementById('status');
        if (status) {
          status.textContent = '‚úÖ Kryptomon switched!';
          setTimeout(() => {
            status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
          }, 1500);
        }
      }
      
      backupGameState();
    }
  });

  gameState.socket.on('gameOver', (data) => {
    console.log('üèÅ Game over:', data);
    gameState.inGame = false;
    gameState.gameData = null;
    
    // Clear backup
    localStorage.removeItem('kryptomon_game_backup');
    
    const isWinner = data.winner === gameState.yourIndex;
    
    if (isWinner) {
      hapticFeedback('success');
      if (tg?.showAlert) {
        tg.showAlert('üèÜ Victory! You defeated all enemy Kryptomon!');
      } else {
        alert('üèÜ Victory! You defeated all enemy Kryptomon!');
      }
    } else {
      hapticFeedback('error');
      if (tg?.showAlert) {
        tg.showAlert('üíÄ Defeat! Your team has fallen!');
      } else {
        alert('üíÄ Defeat! Your team has fallen!');
      }
    }
    
    setTimeout(() => {
      showScreen('start-screen');
    }, 3000);
  });

  gameState.socket.on('opponentDisconnected', (data) => {
    console.log('üíî Opponent disconnected:', data);
    hapticFeedback('warning');
    
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚è≥ Opponent disconnected, waiting...';
    }
    
    if (data.waitingForReconnect) {
      setTimeout(() => {
        if (tg?.showAlert) {
          tg.showAlert('Opponent left the game. Returning to main menu.');
        } else {
          alert('Opponent left the game. Returning to main menu.');
        }
        showScreen('start-screen');
        gameState.inGame = false;
        gameState.gameData = null;
      }, 30000); // Wait 30 seconds for reconnect
    }
  });

  // Enhanced error handling
  gameState.socket.on('error', (error) => {
    console.error('üö® Socket error:', error);
    hapticFeedback('error');
    
    const status = document.getElementById('status');
    if (status && gameState.inGame) {
      // Show user-friendly error message
      if (error.message.includes('team switch')) {
        status.textContent = '‚ùå ' + error.message;
      } else if (error.message.includes('turn')) {
        status.textContent = '‚ùå Not your turn!';
      } else if (error.message.includes('mana')) {
        status.textContent = '‚ùå Not enough mana!';
      } else if (error.message.includes('cooldown')) {
        status.textContent = '‚ùå Skill on cooldown!';
      } else {
        status.textContent = '‚ùå ' + (error.message || 'Action failed');
      }
      
      // Reset status after 3 seconds
      setTimeout(() => {
        if (gameState.inGame) {
          status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
        }
      }, 3000);
    }
  });

  // Network quality monitoring
  setInterval(() => {
    if (gameState.connected && gameState.socket) {
      const startTime = Date.now();
      gameState.socket.emit('ping', startTime);
      
      gameState.socket.once('pong', (timestamp) => {
        const latency = Date.now() - timestamp;
        console.log(`üèì Latency: ${latency}ms`);
        
        // Show latency warning for high ping
        if (latency > 1000) {
          const status = document.getElementById('status');
          if (status && gameState.inGame) {
            status.textContent = `‚ö†Ô∏è High latency: ${latency}ms`;
            setTimeout(() => {
              status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
            }, 2000);
          }
        }
      });
    }
  }, 30000); // Check every 30 seconds
}

// UI Control functions
function enableGameControls() {
  const controls = document.querySelectorAll('.control-btn');
  controls.forEach(btn => {
    btn.style.pointerEvents = 'auto';
    btn.style.opacity = '1';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'auto';
    slot.style.opacity = '1';
  });
}

function disableGameControls() {
  const controls = document.querySelectorAll('.control-btn');
  controls.forEach(btn => {
    btn.style.pointerEvents = 'none';
    btn.style.opacity = '0.5';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'none';
    slot.style.opacity = '0.5';
  });
}

// Enhanced team switching with comprehensive validation
function switchKryptomon(index) {
  console.log('üîÑ Switching to Kryptomon:', index);
  
  if (!gameState.socket || !gameState.inGame) {
    console.log('‚ùå Cannot switch: not in game');
    hapticFeedback('error');
    return;
  }

  if (!gameState.connected) {
    console.log('‚ùå Cannot switch: not connected');
    hapticFeedback('error');
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚ùå Not connected to server!';
      setTimeout(() => {
        status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
      }, 2000);
    }
    return;
  }

  if (!gameState.yourTurn) {
    console.log('‚ùå Cannot switch: not your turn');
    hapticFeedback('error');
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚ùå Can only switch during your turn!';
      setTimeout(() => {
        status.textContent = 'Enemy Turn';
      }, 2000);
    }
    return;
  }

  // Validate the switch locally first
  if (!gameState.gameData || gameState.yourIndex === null) {
    console.log('‚ùå Cannot switch: no game data');
    hapticFeedback('error');
    return;
  }

  const yourData = gameState.gameData.players[gameState.yourIndex];
  if (!yourData || !yourData.team[index]) {
    console.log('‚ùå Cannot switch: invalid kryptomon index');
    hapticFeedback('error');
    return;
  }

  if (!yourData.team[index].isAlive) {
    console.log('‚ùå Cannot switch: kryptomon is defeated');
    hapticFeedback('error');
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚ùå Cannot switch to defeated Kryptomon!';
      setTimeout(() => {
        status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
      }, 2000);
    }
    return;
  }

  if (index === yourData.currentKryptomon) {
    console.log('‚ùå Cannot switch: already using this kryptomon');
    hapticFeedback('light');
    return;
  }

  // Send switch request with timeout protection
  const switchTimeout = setTimeout(() => {
    console.log('‚è∞ Team switch timeout');
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚è∞ Switch request timed out';
      setTimeout(() => {
        status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
      }, 2000);
    }
  }, 10000); // 10 second timeout

  try {
    gameState.socket.emit('requestTeamSwitch', {
      kryptomonIndex: index
    });
    
    hapticFeedback('light');
    const status = document.getElementById('status');
    if (status) {
      status.textContent = 'üîÑ Switching Kryptomon...';
    }
    
    // Clear timeout when we get a response
    const clearTimeoutOnResponse = () => {
      clearTimeout(switchTimeout);
    };
    
    gameState.socket.once('teamSwitched', clearTimeoutOnResponse);
    gameState.socket.once('error', clearTimeoutOnResponse);
    
  } catch (error) {
    clearTimeout(switchTimeout);
    console.error('‚ùå Switch request failed:', error);
    hapticFeedback('error');
  }
}

// Enhanced battle move with validation
function performBattleMove(moveType) {
  console.log('‚öîÔ∏è Performing move:', moveType);
  
  if (!gameState.connected || !gameState.socket) {
    hapticFeedback('error');
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚ùå Not connected!';
    }
    return;
  }

  if (!gameState.inGame) {
    hapticFeedback('error');
    return;
  }

  if (!gameState.yourTurn) {
    hapticFeedback('error');
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚ùå Not your turn!';
      setTimeout(() => {
        status.textContent = 'Enemy Turn';
      }, 2000);
    }
    return;
  }

  // Local validation based on current state
  if (gameState.gameData && gameState.yourIndex !== null) {
    const yourData = gameState.gameData.players[gameState.yourIndex];
    const currentKryptomon = yourData.team[yourData.currentKryptomon];
    
    if (!currentKryptomon.isAlive) {
      hapticFeedback('error');
      return;
    }

    // Check mana requirements
    const moves = {
      attack: { manaCost: 0 },
      defend: { manaCost: 0 },
      skill: { manaCost: 2 },
      ultimate: { manaCost: 6 }
    };

    const move = moves[moveType];
    if (move && move.manaCost > currentKryptomon.mana) {
      hapticFeedback('error');
      const status = document.getElementById('status');
      if (status) {
        status.textContent = '‚ùå Not enough mana!';
        setTimeout(() => {
          status.textContent = 'Your Turn';
        }, 2000);
      }
      return;
    }

    // Check ultimate usage
    if (moveType === 'ultimate' && currentKryptomon.ultimateUsed) {
      hapticFeedback('error');
      const status = document.getElementById('status');
      if (status) {
        status.textContent = '‚ùå Ultimate already used!';
        setTimeout(() => {
          status.textContent = 'Your Turn';
        }, 2000);
      }
      return;
    }

    // Check defend cooldown
    if (moveType === 'defend' && yourData.defendCooldown > 0) {
      hapticFeedback('error');
      const status = document.getElementById('status');
      if (status) {
        status.textContent = `‚ùå Defend on cooldown (${yourData.defendCooldown} turns)!`;
        setTimeout(() => {
          status.textContent = 'Your Turn';
        }, 2000);
      }
      return;
    }
  }

  try {
    // Disable buttons to prevent double-clicks
    const buttons = document.querySelectorAll('.control-btn');
    buttons.forEach(btn => btn.disabled = true);
    
    gameState.socket.emit('battleMove', {
      move: moveType
    });
    
    hapticFeedback('medium');
    
    // Re-enable buttons after a delay
    setTimeout(() => {
      buttons.forEach(btn => btn.disabled = false);
    }, 1000);
    
  } catch (error) {
    console.error('‚ùå Battle move failed:', error);
    hapticFeedback('error');
    
    // Re-enable buttons on error
    const buttons = document.querySelectorAll('.control-btn');
    buttons.forEach(btn => btn.disabled = false);
  }
}
</script>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    height: 100vh;
    overflow: hidden;
    position: fixed;
    width: 100%;
    -webkit-font-smoothing: antialiased;
  }

  /* Connection Status */
  .connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    z-index: 1000;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }

  .connection-status.connecting {
    background: rgba(52, 152, 219, 0.9);
    animation: pulse 1.5s infinite;
  }

  .connection-status.connected {
    background: rgba(46, 204, 113, 0.9);
  }

  .connection-status.disconnected {
    background: rgba(231, 76, 60, 0.9);
    animation: shake 0.5s ease-in-out;
  }

  .connection-status.reconnecting {
    background: rgba(241, 196, 15, 0.9);
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.05); }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }

  .screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    padding: 20px;
    transition: opacity 0.3s ease;
  }

  .hidden {
    display: none !important;
  }

  /* Enhanced Start Screen */
  #start-screen {
    background: rgba(0,0,0,0.95);
    text-align: center;
  }

  #start-screen h1 {
    font-size: clamp(2rem, 5vw, 3rem);
    margin-bottom: 20px;
    color: #FFD700;
    text-shadow: 0 0 20px rgba(255,215,0,0.5);
    animation: glow 2s ease-in-out infinite alternate;
  }

  @keyframes glow {
    from { text-shadow: 0 0 20px rgba(255,215,0,0.5); }
    to { text-shadow: 0 0 30px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.3); }
  }

  #start-screen input {
    padding: 15px;
    font-size: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 25px;
    margin: 10px 0;
    width: 90%;
    max-width: 300px;
    text-align: center;
    background: rgba(255,255,255,0.1);
    color: white;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }

  #start-screen input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
  }

  #start-screen input::placeholder {
    color: rgba(255,255,255,0.7);
  }

  #start-screen button {
    padding: 15px 30px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    border-radius: 25px;
    margin: 10px;
    cursor: pointer;
    width: 90%;
    max-width: 300px;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255,255,255,0.2);
  }

  #start-btn {
    background: linear-gradient(135deg, #2ecc71, #27ae60);
    color: white;
  }

  #start-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(46, 204, 113, 0.3);
  }

  #guest-btn {
    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    color: white;
  }

  #metamask-btn {
    background: linear-gradient(135deg, #f6851b, #ff6b35);
    color: white;
  }

  /* Enhanced Game Screen */
  #game-screen {
    background: url('background.png') center/cover,
                linear-gradient(135deg, #8B4513, #D2691E);
    position: relative;
    overflow: hidden;
  }

  /* Enhanced Game Header */
  .game-header {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.9);
    padding: 10px 20px;
    border-radius: 15px;
    text-align: center;
    z-index: 100;
    backdrop-filter: blur(15px);
    border: 2px solid #FFD700;
    min-width: 200px;
  }

  .game-header div {
    font-size: 14px;
    font-weight: bold;
    margin: 2px 0;
  }

  .timer {
    color: #FFD700;
    font-size: 18px;
    font-weight: bold;
  }

  /* Enhanced Player Stats */
  .player-stats {
    position: absolute;
    top: 80px;
    left: 15px;
    right: 15px;
    display: flex;
    justify-content: space-between;
    gap: 15px;
    z-index: 100;
  }

  .stat-panel {
    background: rgba(0,0,0,0.9);
    padding: 12px 15px;
    border-radius: 15px;
    flex: 1;
    max-width: 45%;
    backdrop-filter: blur(15px);
    border: 2px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }

  .stat-panel.your-turn {
    border-color: #2ecc71;
    box-shadow: 0 0 20px rgba(46, 204, 113, 0.3);
  }

  .stat-panel h3 {
    font-size: 13px;
    margin-bottom: 8px;
    color: #FFD700;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .player-avatar {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid #FFD700;
    object-fit: cover;
  }

  .stat-bar {
    background: rgba(255,255,255,0.2);
    height: 14px;
    border-radius: 7px;
    overflow: hidden;
    margin: 5px 0;
    position: relative;
  }

  .stat-fill {
    height: 100%;
    transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 7px;
  }

  .hp-fill {
    background: linear-gradient(90deg, #e74c3c, #27ae60);
  }

  .mp-fill {
    background: linear-gradient(90deg, #3498db, #9b59b6);
  }

  .stat-text {
    font-size: 11px;
    color: rgba(255,255,255,0.9);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
  }

  /* Enhanced Battle Arena */
  .battle-arena {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 90%;
    max-width: 400px;
    height: 220px;
    gap: 60px;
  }

  .kryptomon {
    width: 130px;
    height: 130px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
    overflow: hidden;
    cursor: pointer;
    border: 3px solid rgba(255,255,255,0.3);
    backdrop-filter: blur(5px);
  }

  .kryptomon img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 17px;
    transition: all 0.3s ease;
  }

  .kryptomon.enemy img {
    transform: scaleX(-1);
  }

  .kryptomon:hover {
    transform: scale(1.05);
    border-color: rgba(255,255,255,0.6);
  }

  /* Team Display Enhanced */
  .team-display {
    position: absolute;
    bottom: 90px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    z-index: 90;
  }

  .team-slot {
    width: 50px;
    height: 50px;
    border-radius: 10px;
    border: 2px solid rgba(255,255,255,0.3);
    background-size: cover;
    background-position: center;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }

  .team-slot.active {
    border-color: #2ecc71;
    box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
    transform: scale(1.1);
  }

  .team-slot.dead {
    opacity: 0.3;
    filter: grayscale(100%);
    cursor: not-allowed;
  }

  .team-slot:not(.dead):not(.active):hover {
    border-color: #3498db;
    transform: scale(1.05);
  }

  /* Enhanced Controls */
  .controls {
    position: absolute;
    bottom: 15px;
    left: 50%;
    transform: translateX(-50%);
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    width: 95%;
    max-width: 350px;
  }

  .control-btn {
    padding: 12px 8px;
    font-size: 12px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    min-height: 55px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 3px;
    border: 2px solid rgba(255,255,255,0.3);
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
  }

  .control-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.5s;
  }

  .control-btn:hover::before {
    left: 100%;
  }

  .control-btn:disabled {
    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    cursor: not-allowed;
    opacity: 0.6;
    transform: none;
  }

  .control-btn:not(:disabled):active {
    transform: scale(0.95);
  }

  .control-btn img {
    width: 18px;
    height: 18px;
    margin-bottom: 2px;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
  }

  .control-btn small {
    font-size: 9px;
    opacity: 0.9;
    font-weight: normal;
  }

  .btn-attack {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
  }

  .btn-defend {
    background: linear-gradient(135deg, #3498db, #2980b9);
  }

  .btn-skill {
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
  }

  .btn-ultimate {
    background: linear-gradient(135deg, #f39c12, #e67e22);
  }

  /* Enhanced Damage Text */
  .damage-text {
    position: absolute;
    font-size: 24px;
    font-weight: bold;
    pointer-events: none;
    z-index: 200;
    animation: damageFloat 2.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  }

  .damage-text.damage {
    color: #e74c3c;
  }

  .damage-text.critical {
    color: #FFD700;
    font-size: 32px;
    text-shadow: 0 0 15px #FFD700;
    animation: criticalFloat 2.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
  }

  .damage-text.heal {
    color: #2ecc71;
  }

  .damage-text.mana {
    color: #3498db;
  }

  @keyframes damageFloat {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    20% { opacity: 1; transform: translateY(-20px) scale(1.2); }
    100% { opacity: 0; transform: translateY(-80px) scale(0.8); }
  }

  @keyframes criticalFloat {
    0% { opacity: 1; transform: translateY(0) scale(1) rotate(-5deg); }
    20% { opacity: 1; transform: translateY(-30px) scale(1.3) rotate(5deg); }
    100% { opacity: 0; transform: translateY(-100px) scale(0.9) rotate(0deg); }
  }

  /* Enhanced Battle Animations */
  .kryptomon.attacking {
    animation: attackBite 1.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .kryptomon.defending {
    animation: defendShield 1.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .kryptomon.skill {
    animation: skillGlow 2.2s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .kryptomon.ultimate {
    animation: ultimateBlast 3.5s cubic-bezier(0.4, 0, 0.2, 1);
  }

  @keyframes attackBite {
    0% { transform: translateX(0) scale(1) rotate(0deg); }
    15% { transform: translateX(20px) scale(1.15) rotate(8deg); }
    30% { transform: translateX(35px) scale(1.25) rotate(-5deg); }
    45% { transform: translateX(40px) scale(1.3) rotate(3deg); }
    60% { transform: translateX(25px) scale(1.2) rotate(-2deg); }
    80% { transform: translateX(10px) scale(1.1) rotate(1deg); }
    100% { transform: translateX(0) scale(1) rotate(0deg); }
  }

  @keyframes defendShield {
    0% { transform: scale(1); filter: drop-shadow(0 0 0px #3498db) brightness(1); }
    20% { transform: scale(0.9); filter: drop-shadow(0 0 20px #3498db) brightness(1.4); }
    40% { transform: scale(1.15); filter: drop-shadow(0 0 30px #3498db) brightness(1.6); }
    60% { transform: scale(1.05); filter: drop-shadow(0 0 25px #3498db) brightness(1.5); }
    80% { transform: scale(0.95); filter: drop-shadow(0 0 15px #3498db) brightness(1.3); }
    100% { transform: scale(1); filter: drop-shadow(0 0 0px #3498db) brightness(1); }
  }

  @keyframes skillGlow {
    0% { transform: scale(1) rotate(0deg); filter: brightness(1) hue-rotate(0deg) saturate(1); }
    15% { transform: scale(1.1) rotate(10deg); filter: brightness(1.5) hue-rotate(45deg) saturate(1.5); }
    30% { transform: scale(1.25) rotate(-15deg); filter: brightness(1.8) hue-rotate(90deg) saturate(2); }
    45% { transform: scale(1.35) rotate(20deg); filter: brightness(2) hue-rotate(135deg) saturate(2.2); }
    60% { transform: scale(1.2) rotate(-10deg); filter: brightness(1.7) hue-rotate(180deg) saturate(1.8); }
    80% { transform: scale(1.1) rotate(5deg); filter: brightness(1.4) hue-rotate(270deg) saturate(1.3); }
    100% { transform: scale(1) rotate(0deg); filter: brightness(1) hue-rotate(360deg) saturate(1); }
  }

  @keyframes ultimateBlast {
    0% { transform: scale(1) rotate(0deg); filter: brightness(1) saturate(1) hue-rotate(0deg) contrast(1); }
    8% { transform: scale(1.3) rotate(20deg); filter: brightness(2.5) saturate(3) hue-rotate(60deg) contrast(1.5); }
    16% { transform: scale(1.6) rotate(-30deg); filter: brightness(3.5) saturate(4) hue-rotate(120deg) contrast(2); }
    24% { transform: scale(1.9) rotate(40deg); filter: brightness(4) saturate(4.5) hue-rotate(180deg) contrast(2.2); }
    32% { transform: scale(2.1) rotate(-50deg); filter: brightness(4.5) saturate(5) hue-rotate(240deg) contrast(2.5); }
    40% { transform: scale(2.3) rotate(45deg); filter: brightness(5) saturate(5.5) hue-rotate(300deg) contrast(3); }
    50% { transform: scale(2.5) rotate(-40deg); filter: brightness(5.5) saturate(6) hue-rotate(360deg) contrast(3.2); }
    65% { transform: scale(2) rotate(30deg); filter: brightness(4.5) saturate(4.5) hue-rotate(300deg) contrast(2.5); }
    80% { transform: scale(1.5) rotate(-20deg); filter: brightness(3) saturate(3) hue-rotate(180deg) contrast(2); }
    90% { transform: scale(1.2) rotate(10deg); filter: brightness(2) saturate(2) hue-rotate(90deg) contrast(1.5); }
    100% { transform: scale(1) rotate(0deg); filter: brightness(1) saturate(1) hue-rotate(0deg) contrast(1); }
  }

  /* Responsive Design */
  @media (max-width: 480px) {
    .battle-arena {
      gap: 40px;
    }
    
    .kryptomon {
      width: 110px;
      height: 110px;
    }
    
    .controls {
      max-width: 320px;
    }
    
    .control-btn {
      min-height: 50px;
      font-size: 11px;
    }
  }

  @media (max-height: 600px) {
    .player-stats {
      top: 60px;
    }
    
    .team-display {
      bottom: 75px;
    }
    
    .controls {
      bottom: 10px;
    }
  }

  /* Loading States */
  .loading {
    opacity: 0.7;
    pointer-events: none;
  }

  .loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid #ffffff;
    border-radius: 50%;
    border-top-color: transparent;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
</style>
</head>

<body>
  <!-- Connection Status -->
  <div id="connection-status" class="connection-status" style="display: none;"></div>

  <!-- Start Screen -->
  <div id="start-screen" class="screen">
    <h1>üêæ Kryptomon Battle Arena</h1>
    <p style="margin-bottom: 30px; font-size: 16px; opacity: 0.9;">Epic NFT battles await!</p>
    
    <input 
      type="text" 
      id="username" 
      placeholder="Enter your name..." 
      value=""
      maxlength="20"
    />
    
    <button id="start-btn" onclick="startGame()">
      ‚öîÔ∏è Start Battle
    </button>
    
    <button id="guest-btn" onclick="startAsGuest()">
      üë§ Play as Guest
    </button>
    
    <button id="metamask-btn" onclick="connectMetaMask()" style="display: none;">
      ü¶ä Connect MetaMask
    </button>
  </div>

  <!-- NFT Selection Screen -->
  <div id="nft-screen" class="screen hidden">
    <h2>Choose Your Team</h2>
    <p>Select 3 Kryptomon NFTs</p>
    <div id="nft-grid" class="nft-grid"></div>
    <button id="confirm-nfts" onclick="confirmNFTSelection()" disabled>
      Confirm Team (0/3)
    </button>
  </div>

  <!-- Waiting Screen -->
  <div id="waiting-screen" class="screen hidden">
    <h2>üîç Finding Opponent...</h2>
    <div class="spinner"></div>
    <p>Preparing for epic battle!</p>
    <button onclick="cancelWaiting()" style="margin-top: 20px; padding: 10px 20px; background: #e74c3c; color: white; border: none; border-radius: 8px; cursor: pointer;">
      Cancel
    </button>
  </div>

  <!-- Game Screen -->
  <div id="game-screen" class="screen hidden">
    <!-- Game Header -->
    <div class="game-header">
      <div id="status">Preparing Battle...</div>
      <div class="timer" id="timer">30</div>
    </div>

    <!-- Player Stats -->
    <div class="player-stats">
      <div class="stat-panel" id="your-stats">
        <h3>
          <img src="you.jpg" alt="You" class="player-avatar" />
          <span id="your-name">You</span>
        </h3>
        <div class="stat-bar">
          <div class="stat-fill hp-fill" id="your-hp" style="width: 100%"></div>
          <div class="stat-text" id="your-hp-text">100/100</div>
        </div>
        <div class="stat-bar">
          <div class="stat-fill mp-fill" id="your-mp" style="width: 0%"></div>
          <div class="stat-text" id="your-mp-text">0/100</div>
        </div>
      </div>

      <div class="stat-panel" id="enemy-stats">
        <h3>
          <img src="enemy.jpg" alt="Enemy" class="player-avatar" />
          <span id="enemy-name">Enemy</span>
        </h3>
        <div class="stat-bar">
          <div class="stat-fill hp-fill" id="enemy-hp" style="width: 100%"></div>
          <div class="stat-text" id="enemy-hp-text">100/100</div>
        </div>
        <div class="stat-bar">
          <div class="stat-fill mp-fill" id="enemy-mp" style="width: 0%"></div>
          <div class="stat-text" id="enemy-mp-text">0/100</div>
        </div>
      </div>
    </div>

    <!-- Battle Arena -->
    <div class="battle-arena">
      <div class="kryptomon" id="your-kryptomon">
        <img src="kryptomon1.png" alt="Your Kryptomon" />
      </div>
      
      <div class="kryptomon enemy" id="enemy-kryptomon">
        <img src="kryptomon2.png" alt="Enemy Kryptomon" />
      </div>
    </div>

    <!-- Team Display -->
    <div class="team-display">
      <div id="your-team" style="display: flex; gap: 8px;">
        <div class="team-slot active" data-index="0" style="background-image: url('kryptomon1.png');"></div>
        <div class="team-slot" data-index="1" style="background-image: url('kryptomon2.png');"></div>
        <div class="team-slot" data-index="2" style="background-image: url('kryptomon3.png');"></div>
      </div>
      
      <div id="enemy-team" style="display: flex; gap: 8px;">
        <div class="team-slot active" style="background-image: url('kryptomon4.png');"></div>
        <div class="team-slot" style="background-image: url('kryptomon5.png');"></div>
        <div class="team-slot" style="background-image: url('kryptomon6.png');"></div>
      </div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button class="control-btn btn-attack" id="attack-btn" onclick="performBattleMove('attack')">
        <img src="attack.png" alt="Attack" />
        Attack
        <small>+2 MP</small>
      </button>
      
      <button class="control-btn btn-defend" id="defend-btn" onclick="performBattleMove('defend')">
        <img src="defence.png" alt="Defend" />
        Defend
        <small>Heal</small>
      </button>
      
      <button class="control-btn btn-skill" id="skill-btn" onclick="performBattleMove('skill')">
        <img src="skill.png" alt="Skill" />
        Skill
        <small>-2 MP</small>
      </button>
      
      <button class="control-btn btn-ultimate" id="ultimate-btn" onclick="performBattleMove('ultimate')">
        <img src="hydra.png" alt="Ultimate" />
        Ultimate
        <small>-6 MP</small>
      </button>
    </div>
  </div>

<script>
// Enhanced DOM management
let currentScreen = 'start-screen';
const elements = {};

// Cache DOM elements
function initializeElements() {
  elements.startScreen = document.getElementById('start-screen');
  elements.nftScreen = document.getElementById('nft-screen');
  elements.waitingScreen = document.getElementById('waiting-screen');
  elements.gameScreen = document.getElementById('game-screen');
  elements.connectionStatus = document.getElementById('connection-status');
  elements.username = document.getElementById('username');
  elements.status = document.getElementById('status');
  elements.timer = document.getElementById('timer');
  elements.yourStats = document.getElementById('your-stats');
  elements.enemyStats = document.getElementById('enemy-stats');
  elements.yourTeam = document.getElementById('your-team');
  elements.enemyTeam = document.getElementById('enemy-team');
  elements.yourKryptomon = document.getElementById('your-kryptomon');
  elements.enemyKryptomon = document.getElementById('enemy-kryptomon');
  
  console.log('üì± DOM elements initialized');
}

// Enhanced screen management
function showScreen(screenId) {
  console.log('üì∫ Switching to screen:', screenId);
  
  const screens = ['start-screen', 'nft-screen', 'waiting-screen', 'game-screen'];
  screens.forEach(id => {
    const screen = document.getElementById(id);
    if (screen) {
      screen.classList.add('hidden');
    }
  });
  
  const targetScreen = document.getElementById(screenId);
  if (targetScreen) {
    targetScreen.classList.remove('hidden');
    currentScreen = screenId;
    
    // Screen-specific initialization
    if (screenId === 'game-screen') {
      enableGameControls();
    }
  }
  
  hapticFeedback('light');
}

// Enhanced audio system
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const sounds = {};

function loadSound(name, url) {
  return fetch(url)
    .then(response => response.arrayBuffer())
    .then(data => audioContext.decodeAudioData(data))
    .then(buffer => {
      sounds[name] = buffer;
    })
    .catch(error => {
      console.warn('Audio load failed:', name, error);
    });
}

function playSound(name) {
  try {
    if (sounds[name] && audioContext.state === 'running') {
      const source = audioContext.createBufferSource();
      source.buffer = sounds[name];
      source.connect(audioContext.destination);
      source.start(0);
    }
  } catch (error) {
    console.warn('Audio play failed:', name, error);
  }
}

// Initialize audio
Promise.all([
  loadSound('attack', 'bite.mp3'),
  loadSound('defend', 'defence.mp3'),
  loadSound('skill', 'skill.mp3'),
  loadSound('ultimate', 'ultimate.mp3')
]).then(() => {
  console.log('üîä Audio system initialized');
});

// Enhanced UI update functions
function updateUI(gameRoom) {
  if (!gameRoom || !gameRoom.players || gameState.yourIndex === null) {
    console.warn('Invalid game room data');
    return;
  }

  try {
    const yourData = gameRoom.players[gameState.yourIndex];
    const enemyData = gameRoom.players[1 - gameState.yourIndex];
    
    if (!yourData || !enemyData) {
      console.warn('Player data missing');
      return;
    }

    // Update turn indicator
    gameState.yourTurn = gameRoom.currentTurn === gameState.yourIndex;
    const status = elements.status || document.getElementById('status');
    if (status) {
      status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
    }

    // Update stat panels
    const yourStats = elements.yourStats || document.getElementById('your-stats');
    const enemyStats = elements.enemyStats || document.getElementById('enemy-stats');
    
    if (yourStats) {
      yourStats.classList.toggle('your-turn', gameState.yourTurn);
    }
    if (enemyStats) {
      enemyStats.classList.toggle('your-turn', !gameState.yourTurn);
    }

    // Update player names
    const yourName = document.getElementById('your-name');
    const enemyName = document.getElementById('enemy-name');
    if (yourName) yourName.textContent = yourData.username || 'You';
    if (enemyName) enemyName.textContent = enemyData.username || 'Enemy';

    // Update current Kryptomon stats
    const yourCurrentKryptomon = yourData.team[yourData.currentKryptomon];
    const enemyCurrentKryptomon = enemyData.team[enemyData.currentKryptomon];

    if (yourCurrentKryptomon && enemyCurrentKryptomon) {
      // Update HP bars
      updateStatBar('your-hp', 'your-hp-text', yourCurrentKryptomon.hp, yourCurrentKryptomon.maxHp, 'HP');
      updateStatBar('enemy-hp', 'enemy-hp-text', enemyCurrentKryptomon.hp, enemyCurrentKryptomon.maxHp, 'HP');
      
      // Update MP bars
      updateStatBar('your-mp', 'your-mp-text', yourCurrentKryptomon.mana, yourCurrentKryptomon.maxMana, 'MP');
      updateStatBar('enemy-mp', 'enemy-mp-text', enemyCurrentKryptomon.mana, enemyCurrentKryptomon.maxMana, 'MP');
      
      // Update Kryptomon images
      const yourImg = document.querySelector('#your-kryptomon img');
      const enemyImg = document.querySelector('#enemy-kryptomon img');
      
      if (yourImg) {
        yourImg.src = `kryptomon${yourCurrentKryptomon.sprite}.png`;
        yourImg.alt = yourCurrentKryptomon.name;
      }
      if (enemyImg) {
        enemyImg.src = `kryptomon${enemyCurrentKryptomon.sprite}.png`;
        enemyImg.alt = enemyCurrentKryptomon.name;
      }
    }

    // Update button states
    updateButtons();
    
    console.log('‚úÖ UI updated successfully');
    
  } catch (error) {
    console.error('‚ùå UI update failed:', error);
  }
}

function updateStatBar(barId, textId, current, max, type) {
  const bar = document.getElementById(barId);
  const text = document.getElementById(textId);
  
  if (bar) {
    const percentage = Math.max(0, Math.min(100, (current / max) * 100));
    bar.style.width = percentage + '%';
  }
  
  if (text) {
    text.textContent = `${current}/${max}`;
  }
}

function updateButtons() {
  if (!gameState.gameData || gameState.yourIndex === null) return;

  const yourData = gameState.gameData.players[gameState.yourIndex];
  const currentKryptomon = yourData.team[yourData.currentKryptomon];
  
  const attackBtn = document.getElementById('attack-btn');
  const defendBtn = document.getElementById('defend-btn');
  const skillBtn = document.getElementById('skill-btn');
  const ultimateBtn = document.getElementById('ultimate-btn');

  // Disable all buttons if not your turn or not connected
  const isEnabled = gameState.yourTurn && gameState.connected && currentKryptomon.isAlive;
  
  if (attackBtn) attackBtn.disabled = !isEnabled;
  if (defendBtn) defendBtn.disabled = !isEnabled || yourData.defendCooldown > 0;
  if (skillBtn) skillBtn.disabled = !isEnabled || currentKryptomon.mana < 2;
  if (ultimateBtn) ultimateBtn.disabled = !isEnabled || currentKryptomon.mana < 6 || currentKryptomon.ultimateUsed;
  
  // Update button text with cooldown info
  if (defendBtn && yourData.defendCooldown > 0) {
    defendBtn.innerHTML = `<img src="defence.png" alt="Defend" />Defend<small>Cooldown: ${yourData.defendCooldown}</small>`;
  } else if (defendBtn) {
    defendBtn.innerHTML = `<img src="defence.png" alt="Defend" />Defend<small>Heal</small>`;
  }
}

function updateTeamDisplay() {
  if (!gameState.gameData || gameState.yourIndex === null) return;

  const yourData = gameState.gameData.players[gameState.yourIndex];
  const enemyData = gameState.gameData.players[1 - gameState.yourIndex];
  
  // Update your team display
  const yourSlots = document.querySelectorAll('#your-team .team-slot');
  yourSlots.forEach((slot, index) => {
    slot.classList.remove('active', 'dead');
    
    if (yourData.team[index]) {
      slot.style.backgroundImage = `url('kryptomon${yourData.team[index].sprite}.png')`;
      
      if (yourData.team[index].isAlive) {
        if (index === yourData.currentKryptomon) {
          slot.classList.add('active');
        }
      } else {
        slot.classList.add('dead');
      }
    }
  });
  
  // Update enemy team display
  const enemySlots = document.querySelectorAll('#enemy-team .team-slot');
  enemySlots.forEach((slot, index) => {
    slot.classList.remove('active', 'dead');
    
    if (enemyData.team[index]) {
      slot.style.backgroundImage = `url('kryptomon${enemyData.team[index].sprite}.png')`;
      
      if (enemyData.team[index].isAlive) {
        if (index === enemyData.currentKryptomon) {
          slot.classList.add('active');
        }
      } else {
        slot.classList.add('dead');
      }
    }
  });
}

// Enhanced visual effects
function showDamageText(damageInfo) {
  if (!damageInfo) return;

  const targetElement = damageInfo.target === 'enemy' ? 
    document.getElementById('enemy-kryptomon') : 
    document.getElementById('your-kryptomon');
    
  if (!targetElement) return;

  const damageText = document.createElement('div');
  damageText.className = 'damage-text';
  
  if (damageInfo.damage > 0) {
    if (damageInfo.target === 'enemy') {
      damageText.textContent = `-${damageInfo.damage}`;
      damageText.classList.add(damageInfo.isCritical ? 'critical' : 'damage');
    } else {
      damageText.textContent = `+${damageInfo.damage}`;
      damageText.classList.add('heal');
    }
  } else if (damageInfo.manaGain) {
    damageText.textContent = `+${damageInfo.manaGain} MP`;
    damageText.classList.add('mana');
  }

  // Position the damage text
  const rect = targetElement.getBoundingClientRect();
  damageText.style.position = 'fixed';
  damageText.style.left = (rect.left + rect.width / 2) + 'px';
  damageText.style.top = (rect.top + rect.height / 2) + 'px';
  damageText.style.transform = 'translate(-50%, -50%)';
  damageText.style.zIndex = '1000';

  document.body.appendChild(damageText);

  // Remove after animation
  setTimeout(() => {
    if (damageText.parentNode) {
      damageText.parentNode.removeChild(damageText);
    }
  }, 2500);
}

function applyMoveAnimation(moveResult) {
  if (!moveResult || !moveResult.moveType) return;

  const isYourMove = moveResult.playerIndex === gameState.yourIndex;
  const animatingElement = isYourMove ? 
    document.getElementById('your-kryptomon') : 
    document.getElementById('enemy-kryptomon');

  if (!animatingElement) return;

  // Remove existing animation classes
  animatingElement.classList.remove('attacking', 'defending', 'skill', 'ultimate');
  
  // Add new animation class
  setTimeout(() => {
    animatingElement.classList.add(moveResult.moveType);
    
    // Remove animation class after animation completes
    const animationDuration = {
      'attacking': 1800,
      'defending': 1800,
      'skill': 2200,
      'ultimate': 3500
    };
    
    setTimeout(() => {
      animatingElement.classList.remove(moveResult.moveType);
    }, animationDuration[moveResult.moveType] || 1800);
    
  }, 50);
}

// Game initialization functions
function startGame() {
  const username = elements.username?.value.trim() || document.getElementById('username')?.value.trim();
  if (username && username.length > 0) {
    gameState.playerName = username.substring(0, 20); // Limit length
  }
  
  hapticFeedback('medium');
  connectToServer();
}

function startAsGuest() {
  gameState.playerName = 'Guest_' + Math.random().toString(36).substr(2, 5);
  hapticFeedback('medium');
  connectToServer();
}

function cancelWaiting() {
  if (gameState.socket) {
    gameState.socket.disconnect();
  }
  showScreen('start-screen');
  hapticFeedback('light');
}

// Enhanced event listeners
document.addEventListener('DOMContentLoaded', () => {
  initializeElements();
  
  // Set initial username from Telegram if available
  const usernameInput = document.getElementById('username');
  if (usernameInput && gameState.playerName !== 'Anonymous') {
    usernameInput.value = gameState.playerName;
  }
  
  // Team switching event listener
  if (elements.yourTeam) {
    elements.yourTeam.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const slot = e.target.closest('.team-slot');
      if (!slot) return;
      
      const index = parseInt(slot.dataset.index);
      if (isNaN(index)) return;
      
      // Validate turn and connection
      if (!gameState.yourTurn) {
        hapticFeedback('error');
        const status = document.getElementById('status');
        if (status) {
          status.textContent = '‚ùå Can only switch during your turn!';
          setTimeout(() => {
            status.textContent = 'Enemy Turn';
          }, 2000);
        }
        return;
      }
      
      if (!gameState.connected) {
        hapticFeedback('error');
        const status = document.getElementById('status');
        if (status) {
          status.textContent = '‚ùå Not connected to server!';
          setTimeout(() => {
            status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
          }, 2000);
        }
        return;
      }
      
      switchKryptomon(index);
    });
  }
  
  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (currentScreen !== 'game-screen' || !gameState.yourTurn) return;
    
    switch(e.key.toLowerCase()) {
      case 'a':
      case '1':
        performBattleMove('attack');
        break;
      case 'd':
      case '2':
        performBattleMove('defend');
        break;
      case 's':
      case '3':
        performBattleMove('skill');
        break;
      case 'u':
      case '4':
        performBattleMove('ultimate');
        break;
    }
  });
  
  // Touch event optimization
  document.addEventListener('touchstart', (e) => {
    // Prevent default for game elements to improve responsiveness
    if (e.target.closest('.control-btn') || e.target.closest('.team-slot')) {
      e.preventDefault();
    }
  }, { passive: false });
  
  console.log('üéÆ Game initialized successfully');
});

// Error boundary
window.addEventListener('error', (e) => {
  console.error('üö® Global error:', e.error);
  hapticFeedback('error');
});

window.addEventListener('unhandledrejection', (e) => {
  console.error('üö® Unhandled promise rejection:', e.reason);
});

// Initialize connection status element
document.addEventListener('DOMContentLoaded', () => {
  connectionStatus.element = document.getElementById('connection-status');
});

console.log('üöÄ Kryptomon Battle Arena loaded successfully!');
</script>
</body>
</html>
