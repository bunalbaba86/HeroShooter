<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Kryptomon Battle Arena</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<script>
// Enhanced Telegram WebApp integration
const tg = window.Telegram?.WebApp;
const isTelegramWebApp = !!tg;

// Global game state with enhanced management
const gameState = {
  connected: false,
  socket: null,
  inGame: false,
  gameData: null,
  yourIndex: null,
  yourTurn: false,
  playerName: 'Anonymous',
  telegramUserId: null,
  connectionAttempts: 0,
  lastConnectionError: null,
  reconnectTimeout: null,
  gameBackup: null
};

// Enhanced connection status tracking
const connectionStatus = {
  element: null,
  lastUpdate: Date.now(),
  retryCount: 0,
  maxRetries: 5
};

if (tg) {
  console.log('üì± Telegram WebApp detected');
  tg.ready();
  tg.expand();
  
  // Get user info from Telegram
  const user = tg.initDataUnsafe?.user;
  if (user) {
    gameState.playerName = user.first_name || user.username || 'Player';
    gameState.telegramUserId = user.id;
    console.log('üë§ Telegram user:', gameState.playerName);
  }
  
  // Enhanced haptic feedback
  function hapticFeedback(type = 'medium') {
    try {
      if (tg.HapticFeedback) {
        switch(type) {
          case 'light':
            tg.HapticFeedback.impactOccurred('light');
            break;
          case 'medium':
            tg.HapticFeedback.impactOccurred('medium');
            break;
          case 'heavy':
          case 'error':
            tg.HapticFeedback.impactOccurred('heavy');
            break;
          case 'success':
            tg.HapticFeedback.notificationOccurred('success');
            break;
          case 'warning':
            tg.HapticFeedback.notificationOccurred('warning');
            break;
        }
      }
    } catch (error) {
      console.error('Haptic feedback error:', error);
    }
  }
  
  // Show main button after game
  function showMainButton(text, callback) {
    try {
      tg.MainButton.text = text;
      tg.MainButton.show();
      tg.MainButton.onClick(callback);
    } catch (error) {
      console.error('Main button error:', error);
    }
  }
} else {
  // Fallback haptic function for non-Telegram
  function hapticFeedback(type = 'medium') {
    if (navigator.vibrate) {
      switch(type) {
        case 'light':
          navigator.vibrate(50);
          break;
        case 'medium':
          navigator.vibrate(100);
          break;
        case 'heavy':
        case 'error':
          navigator.vibrate([100, 50, 100]);
          break;
        case 'success':
          navigator.vibrate([50, 50, 50]);
          break;
      }
    }
  }
  
  function showMainButton() {
    // No-op for non-Telegram
  }
}

// Screen management function
function showScreen(screenId) {
  console.log('üñ•Ô∏è Showing screen:', screenId);
  
  // Hide all screens
  const screens = document.querySelectorAll('.screen');
  screens.forEach(screen => {
    screen.classList.add('hidden');
  });
  
  // Show target screen
  const targetScreen = document.getElementById(screenId);
  if (targetScreen) {
    targetScreen.classList.remove('hidden');
    console.log('‚úÖ Screen shown:', screenId);
  } else {
    console.error('‚ùå Screen not found:', screenId);
  }
}

// Enhanced connection management
function updateConnectionStatus(status) {
  let statusElement = document.getElementById('connection-status');
  if (!statusElement) {
    // Create status element if it doesn't exist
    statusElement = document.createElement('div');
    statusElement.id = 'connection-status';
    statusElement.className = 'connection-status';
    document.body.appendChild(statusElement);
  }
  
  const now = Date.now();
  connectionStatus.lastUpdate = now;
  
  switch(status) {
    case 'connecting':
      statusElement.textContent = 'üîÑ Connecting...';
      statusElement.className = 'connection-status connecting';
      statusElement.style.display = 'block';
      break;
    case 'connected':
      statusElement.textContent = '‚úÖ Connected';
      statusElement.className = 'connection-status connected';
      statusElement.style.display = 'block';
      connectionStatus.retryCount = 0;
      // Hide after 2 seconds
      setTimeout(() => {
        statusElement.style.display = 'none';
      }, 2000);
      break;
    case 'disconnected':
      statusElement.textContent = '‚ùå Disconnected';
      statusElement.className = 'connection-status disconnected';
      statusElement.style.display = 'block';
      break;
    case 'reconnecting':
      statusElement.textContent = `üîÑ Reconnecting... (${connectionStatus.retryCount}/${connectionStatus.maxRetries})`;
      statusElement.className = 'connection-status reconnecting';
      statusElement.style.display = 'block';
      break;
  }
}

// Enhanced game state backup/restore
function backupGameState() {
  if (gameState.inGame && gameState.gameData) {
    try {
      const backup = {
        gameData: gameState.gameData,
        yourIndex: gameState.yourIndex,
        playerName: gameState.playerName,
        telegramUserId: gameState.telegramUserId,
        timestamp: Date.now()
      };
      localStorage.setItem('kryptomon_game_backup', JSON.stringify(backup));
      gameState.gameBackup = backup;
      console.log('üíæ Game state backed up');
    } catch (error) {
      console.error('‚ùå Backup failed:', error);
    }
  }
}

function restoreGameState() {
  try {
    const backup = localStorage.getItem('kryptomon_game_backup');
    if (backup) {
      const data = JSON.parse(backup);
      // Only restore if backup is less than 5 minutes old
      if (Date.now() - data.timestamp < 300000) {
        console.log('üîÑ Restoring game state');
        return data;
      } else {
        console.log('‚è∞ Backup too old, discarding');
        localStorage.removeItem('kryptomon_game_backup');
      }
    }
  } catch (error) {
    console.error('‚ùå Restore failed:', error);
    localStorage.removeItem('kryptomon_game_backup');
  }
  return null;
}

// Enhanced connection with retry logic and fallback
function connectToServer(retryCount = 0) {
  if (retryCount >= connectionStatus.maxRetries) {
    updateConnectionStatus('disconnected');
    if (tg?.showAlert) {
      tg.showAlert('Unable to connect to server. Please check your internet connection and try again.');
    } else {
      alert('Unable to connect to server. Please check your internet connection and try again.');
    }
    return;
  }

  updateConnectionStatus(retryCount === 0 ? 'connecting' : 'reconnecting');
  connectionStatus.retryCount = retryCount;
  
  // Use same domain (Vercel)
  const serverUrl = window.location.origin;
  console.log(`üîå Connecting to server (attempt ${retryCount + 1}):`, serverUrl);
  
  // Clear any existing connection
  if (gameState.socket) {
    gameState.socket.disconnect();
    gameState.socket = null;
  }

  gameState.socket = io(serverUrl, {
    withCredentials: true,
    timeout: 30000,
    transports: ['polling', 'websocket'],
    forceNew: true,
    reconnection: true,
    reconnectionAttempts: 3,
    reconnectionDelay: 2000,
    reconnectionDelayMax: 10000,
    maxReconnectionAttempts: 3,
    pingTimeout: 60000,
    pingInterval: 25000
  });

  // Enhanced game event handlers
  setupGameEventHandlers();
}

// Enhanced game event handlers
function setupGameEventHandlers() {
  if (!gameState.socket) return;

  // Clear existing listeners to prevent duplicates
  gameState.socket.removeAllListeners();

  // Connection events
  gameState.socket.on('connect', () => {
    console.log('‚úÖ Connected to server');
    gameState.connected = true;
    gameState.connectionAttempts = 0;
    updateConnectionStatus('connected');
    
    // Clear any reconnect timeout
    if (gameState.reconnectTimeout) {
      clearTimeout(gameState.reconnectTimeout);
      gameState.reconnectTimeout = null;
    }
    
    // Enable UI
    enableGameUI();
    
    // Join game immediately
    console.log('üéÆ Auto-joining game...');
    gameState.socket.emit('joinGame', {
      username: gameState.playerName,
      telegramUserId: gameState.telegramUserId,
      isTelegramUser: isTelegramWebApp
    });
  });

  gameState.socket.on('connect_error', (error) => {
    console.error('‚ùå Connection error:', error);
    gameState.connected = false;
    gameState.lastConnectionError = error;
    
    // Exponential backoff retry
    const delay = Math.min(Math.pow(2, connectionStatus.retryCount) * 1000, 10000);
    console.log(`üîÑ Retrying connection in ${delay}ms...`);
    
    gameState.reconnectTimeout = setTimeout(() => {
      connectToServer(connectionStatus.retryCount + 1);
    }, delay);
  });

  gameState.socket.on('disconnect', (reason) => {
    console.log('‚ùå Disconnected:', reason);
    gameState.connected = false;
    updateConnectionStatus('disconnected');
    
    // Backup current game state
    backupGameState();
    
    // Disable UI elements
    disableGameUI();
    
    // Auto-reconnect for certain reasons
    if (reason === 'io server disconnect') {
      if (tg?.showAlert) {
        tg.showAlert('Server disconnected. Please restart the game.');
      }
    } else {
      console.log('üîÑ Attempting auto-reconnect...');
      gameState.reconnectTimeout = setTimeout(() => {
        connectToServer(0);
      }, 3000);
    }
  });

  gameState.socket.on('reconnect', (attemptNumber) => {
    console.log('‚úÖ Reconnected after', attemptNumber, 'attempts');
    updateConnectionStatus('connected');
    hapticFeedback('success');
    enableGameUI();
  });

  // Game events
  gameState.socket.on('waitingForOpponent', (data) => {
    console.log('‚è≥ Waiting for opponent...', data);
    showScreen('waiting-screen');
    
    const waitingMessage = document.getElementById('waiting-message');
    if (waitingMessage) {
      waitingMessage.textContent = data.message || 'Finding opponent...';
    }
    
    const spinner = document.querySelector('.spinner');
    if (spinner) {
      spinner.style.display = 'block';
    }
  });

  gameState.socket.on('gameStarted', (data) => {
    console.log('üéÆ Game started!', data);
    try {
      gameState.inGame = true;
      gameState.gameData = data.gameRoom;
      gameState.yourIndex = data.yourIndex;
      gameState.yourTurn = data.gameRoom.currentTurn === data.yourIndex;
      
      console.log('üë§ Your index:', gameState.yourIndex);
      console.log('üéØ Your turn:', gameState.yourTurn);
      
      showScreen('game-screen');
      updateUI(data.gameRoom);
      hapticFeedback('success');
      
      // Clear backup
      localStorage.removeItem('kryptomon_game_backup');
      
    } catch (error) {
      console.error('‚ùå Game start error:', error);
      if (tg?.showAlert) {
        tg.showAlert('Failed to start game. Please try again.');
      } else {
        alert('Failed to start game. Please try again.');
      }
    }
  });

  gameState.socket.on('moveResult', (data) => {
    console.log('‚öîÔ∏è Move result:', data);
    try {
      gameState.gameData = data.gameRoom;
      gameState.yourTurn = data.gameRoom.currentTurn === gameState.yourIndex;
      
      processMoveResult(data.moveResult);
      updateUI(data.gameRoom);
      backupGameState();
      
    } catch (error) {
      console.error('‚ùå Move result error:', error);
    }
  });

  gameState.socket.on('teamSwitched', (data) => {
    console.log('‚úÖ Team switched:', data);
    try {
      if (data.success) {
        gameState.gameData = data.gameRoom;
        updateUI(data.gameRoom);
        
        if (data.playerIndex === gameState.yourIndex) {
          hapticFeedback('success');
          showMessage('‚úÖ Kryptomon switched!', 'success');
        }
        
        backupGameState();
      }
    } catch (error) {
      console.error('‚ùå Team switch error:', error);
    }
  });

  gameState.socket.on('gameOver', (data) => {
    console.log('üèÅ Game over:', data);
    gameState.inGame = false;
    gameState.gameData = null;
    
    localStorage.removeItem('kryptomon_game_backup');
    
    const isWinner = data.winner === gameState.yourIndex;
    
    if (isWinner) {
      hapticFeedback('success');
      if (tg?.showAlert) {
        tg.showAlert('üèÜ Victory! You defeated all enemy Kryptomon!');
      } else {
        alert('üèÜ Victory! You defeated all enemy Kryptomon!');
      }
    } else {
      hapticFeedback('error');
      if (tg?.showAlert) {
        tg.showAlert('üíÄ Defeat! Your team has fallen!');
      } else {
        alert('üíÄ Defeat! Your team has fallen!');
      }
    }
    
    setTimeout(() => {
      showScreen('start-screen');
    }, 3000);
  });

  gameState.socket.on('opponentDisconnected', (data) => {
    console.log('üíî Opponent disconnected:', data);
    hapticFeedback('warning');
    
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚è≥ Opponent disconnected, waiting...';
    }
    
    if (data.waitingForReconnect) {
      setTimeout(() => {
        if (tg?.showAlert) {
          tg.showAlert('Opponent left the game. Returning to main menu.');
        } else {
          alert('Opponent left the game. Returning to main menu.');
        }
        showScreen('start-screen');
        gameState.inGame = false;
        gameState.gameData = null;
      }, 30000);
    }
  });

  gameState.socket.on('error', (error) => {
    console.error('üö® Socket error:', error);
    hapticFeedback('error');
    
    const status = document.getElementById('status');
    if (status && gameState.inGame) {
      status.textContent = '‚ùå ' + (error.message || 'Action failed');
      setTimeout(() => {
        if (gameState.inGame) {
          status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
        }
      }, 3000);
    }
  });

  // Network quality monitoring
  setInterval(() => {
    if (gameState.connected && gameState.socket) {
      const startTime = Date.now();
      gameState.socket.emit('ping', startTime);
      
      gameState.socket.once('pong', (timestamp) => {
        const latency = Date.now() - timestamp;
        console.log(`üèì Latency: ${latency}ms`);
      });
    }
  }, 30000);
}

// UI state management
function enableGameUI() {
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(btn => {
    btn.disabled = false;
    btn.style.opacity = '1';
    btn.style.pointerEvents = 'auto';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'auto';
    slot.style.opacity = '1';
  });
}

function disableGameUI() {
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(btn => {
    btn.disabled = true;
    btn.style.opacity = '0.5';
    btn.style.pointerEvents = 'none';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'none';
    slot.style.opacity = '0.5';
  });
}

// Enhanced UI update function
function updateUI(gameRoom) {
  console.log('üé® Updating UI with game data:', gameRoom);
  
  if (!gameRoom || gameState.yourIndex === null) return;
  
  try {
    // Update status
    const status = document.getElementById('status');
    if (status) {
      status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
    }
    
    // Update player stats
    updatePlayerStats(gameRoom);
    
    // Update team displays
    updateTeamDisplay();
    
    // Update control buttons
    updateButtons();
    
    // Update Kryptomon displays
    updateKryptomonDisplay(gameRoom);
    
  } catch (error) {
    console.error('‚ùå UI update error:', error);
  }
}

// Update player stats
function updatePlayerStats(gameRoom) {
  if (!gameRoom || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameRoom.players[gameState.yourIndex];
    const enemyData = gameRoom.players[1 - gameState.yourIndex];
    
    if (!yourData || !enemyData) return;
    
    const yourKryptomon = yourData.team[yourData.currentKryptomon];
    const enemyKryptomon = enemyData.team[enemyData.currentKryptomon];
    
    // Update your stats
    const yourHpBar = document.querySelector('.your-stats .hp-fill');
    const yourMpBar = document.querySelector('.your-stats .mp-fill');
    const yourHpText = document.querySelector('.your-stats .hp-text');
    const yourMpText = document.querySelector('.your-stats .mp-text');
    
    if (yourHpBar && yourKryptomon) {
      const hpPercent = (yourKryptomon.hp / yourKryptomon.maxHp) * 100;
      yourHpBar.style.width = hpPercent + '%';
    }
    
    if (yourMpBar && yourKryptomon) {
      const mpPercent = (yourKryptomon.mana / yourKryptomon.maxMana) * 100;
      yourMpBar.style.width = mpPercent + '%';
    }
    
    if (yourHpText && yourKryptomon) {
      yourHpText.textContent = `${yourKryptomon.hp}/${yourKryptomon.maxHp}`;
    }
    
    if (yourMpText && yourKryptomon) {
      yourMpText.textContent = `${yourKryptomon.mana}/${yourKryptomon.maxMana}`;
    }
    
    // Update enemy stats
    const enemyHpBar = document.querySelector('.enemy-stats .hp-fill');
    const enemyMpBar = document.querySelector('.enemy-stats .mp-fill');
    const enemyHpText = document.querySelector('.enemy-stats .hp-text');
    const enemyMpText = document.querySelector('.enemy-stats .mp-text');
    
    if (enemyHpBar && enemyKryptomon) {
      const hpPercent = (enemyKryptomon.hp / enemyKryptomon.maxHp) * 100;
      enemyHpBar.style.width = hpPercent + '%';
    }
    
    if (enemyMpBar && enemyKryptomon) {
      const mpPercent = (enemyKryptomon.mana / enemyKryptomon.maxMana) * 100;
      enemyMpBar.style.width = mpPercent + '%';
    }
    
    if (enemyHpText && enemyKryptomon) {
      enemyHpText.textContent = `${enemyKryptomon.hp}/${enemyKryptomon.maxHp}`;
    }
    
    if (enemyMpText && enemyKryptomon) {
      enemyMpText.textContent = `${enemyKryptomon.mana}/${enemyKryptomon.maxMana}`;
    }
    
  } catch (error) {
    console.error('‚ùå Player stats update error:', error);
  }
}

// Update team display
function updateTeamDisplay() {
  if (!gameState.gameData || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameState.gameData.players[gameState.yourIndex];
    const enemyData = gameState.gameData.players[1 - gameState.yourIndex];
    
    // Update your team slots
    const yourSlots = document.querySelectorAll('.your-team .team-slot');
    yourSlots.forEach((slot, index) => {
      if (yourData.team[index]) {
        slot.classList.remove('active', 'dead');
        
        if (yourData.team[index].isAlive) {
          if (index === yourData.currentKryptomon) {
            slot.classList.add('active');
          }
        } else {
          slot.classList.add('dead');
        }
        
        // Update sprite
        const img = slot.querySelector('img');
        if (img) {
          img.src = `kryptomon${yourData.team[index].sprite}.png`;
        }
      }
    });
    
    // Update enemy team slots
    const enemySlots = document.querySelectorAll('.enemy-team .team-slot');
    enemySlots.forEach((slot, index) => {
      if (enemyData.team[index]) {
        slot.classList.remove('active', 'dead');
        
        if (enemyData.team[index].isAlive) {
          if (index === enemyData.currentKryptomon) {
            slot.classList.add('active');
          }
        } else {
          slot.classList.add('dead');
        }
        
        // Update sprite
        const img = slot.querySelector('img');
        if (img) {
          img.src = `kryptomon${enemyData.team[index].sprite}.png`;
        }
      }
    });
    
  } catch (error) {
    console.error('‚ùå Team display update error:', error);
  }
}

// Update control buttons
function updateButtons() {
  if (!gameState.gameData || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameState.gameData.players[gameState.yourIndex];
    const currentKryptomon = yourData.team[yourData.currentKryptomon];
    
    if (!currentKryptomon) return;
    
    // Update button states
    const attackBtn = document.getElementById('attack-btn');
    const defendBtn = document.getElementById('defend-btn');
    const skillBtn = document.getElementById('skill-btn');
    const ultimateBtn = document.getElementById('ultimate-btn');
    
    // Attack - always available if alive
    if (attackBtn) {
      attackBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive;
    }
    
    // Defend - check cooldown
    if (defendBtn) {
      defendBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || yourData.defendCooldown > 0;
      if (yourData.defendCooldown > 0) {
        defendBtn.textContent = `Defend (${yourData.defendCooldown})`;
      } else {
        defendBtn.textContent = 'Defend';
      }
    }
    
    // Skill - check mana
    if (skillBtn) {
      skillBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || currentKryptomon.mana < 2;
      skillBtn.querySelector('span').textContent = 'Skill (2 MP)';
    }
    
    // Ultimate - check mana and usage
    if (ultimateBtn) {
      ultimateBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || 
                            currentKryptomon.mana < 6 || currentKryptomon.ultimateUsed;
      if (currentKryptomon.ultimateUsed) {
        ultimateBtn.querySelector('span').textContent = 'Ultimate (Used)';
      } else {
        ultimateBtn.querySelector('span').textContent = 'Ultimate (6 MP)';
      }
    }
    
  } catch (error) {
    console.error('‚ùå Button update error:', error);
  }
}

// Update Kryptomon display
function updateKryptomonDisplay(gameRoom) {
  if (!gameRoom || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameRoom.players[gameState.yourIndex];
    const enemyData = gameRoom.players[1 - gameState.yourIndex];
    
    // Update your Kryptomon
    const yourKryptomon = document.querySelector('.kryptomon.yours img');
    if (yourKryptomon && yourData.team[yourData.currentKryptomon]) {
      yourKryptomon.src = `kryptomon${yourData.team[yourData.currentKryptomon].sprite}.png`;
    }
    
    // Update enemy Kryptomon
    const enemyKryptomon = document.querySelector('.kryptomon.enemy img');
    if (enemyKryptomon && enemyData.team[enemyData.currentKryptomon]) {
      enemyKryptomon.src = `kryptomon${enemyData.team[enemyData.currentKryptomon].sprite}.png`;
    }
    
  } catch (error) {
    console.error('‚ùå Kryptomon display update error:', error);
  }
}

// Process move result with animations
function processMoveResult(moveResult) {
  try {
    console.log('‚ö° Processing move result:', moveResult);
    
    // Play sound effect
    if (moveResult.soundEffect) {
      playSound(moveResult.soundEffect);
    }
    
    // Show damage text
    if (moveResult.damageInfo) {
      showDamageText(moveResult.damageInfo);
    }
    
    // Apply visual effects
    applyMoveAnimation(moveResult);
    
    // Handle special effects
    if (moveResult.effects && moveResult.effects.length > 0) {
      moveResult.effects.forEach(effect => {
        handleSpecialEffect(effect);
      });
    }
    
  } catch (error) {
    console.error('‚ùå Move result processing error:', error);
  }
}

// Apply move animations
function applyMoveAnimation(moveResult) {
  try {
    const isYourMove = moveResult.playerIndex === gameState.yourIndex;
    const kryptomonElement = document.querySelector(isYourMove ? '.kryptomon.yours' : '.kryptomon.enemy');
    
    if (kryptomonElement) {
      // Remove existing animation classes
      kryptomonElement.classList.remove('attacking', 'defending', 'skill', 'ultimate');
      
      // Add new animation class
      switch(moveResult.moveType) {
        case 'attack':
          kryptomonElement.classList.add('attacking');
          break;
        case 'defend':
          kryptomonElement.classList.add('defending');
          break;
        case 'skill':
          kryptomonElement.classList.add('skill');
          break;
        case 'ultimate':
          kryptomonElement.classList.add('ultimate');
          break;
      }
      
      // Remove animation class after animation completes
      setTimeout(() => {
        kryptomonElement.classList.remove('attacking', 'defending', 'skill', 'ultimate');
      }, 3000);
    }
    
  } catch (error) {
    console.error('‚ùå Animation error:', error);
  }
}

// Show damage text
function showDamageText(damageInfo) {
  try {
    const isTargetEnemy = damageInfo.target === 'enemy';
    const targetElement = document.querySelector(isTargetEnemy ? '.kryptomon.enemy' : '.kryptomon.yours');
    
    if (targetElement) {
      const damageText = document.createElement('div');
      damageText.className = 'damage-text';
      
      if (damageInfo.damage > 0) {
        if (damageInfo.target === 'self') {
          damageText.textContent = `+${damageInfo.damage}`;
          damageText.classList.add('heal');
        } else {
          damageText.textContent = `-${damageInfo.damage}`;
          if (damageInfo.isCritical) {
            damageText.classList.add('critical');
            damageText.textContent += ' CRIT!';
          } else {
            damageText.classList.add('damage');
          }
        }
      }
      
      // Position the damage text
      const rect = targetElement.getBoundingClientRect();
      damageText.style.left = (rect.left + rect.width / 2) + 'px';
      damageText.style.top = (rect.top + rect.height / 2) + 'px';
      damageText.style.position = 'fixed';
      damageText.style.zIndex = '1000';
      
      document.body.appendChild(damageText);
      
      // Remove after animation
      setTimeout(() => {
        if (damageText.parentNode) {
          damageText.parentNode.removeChild(damageText);
        }
      }, 2500);
    }
    
  } catch (error) {
    console.error('‚ùå Damage text error:', error);
  }
}

// Handle special effects
function handleSpecialEffect(effect) {
  switch(effect) {
    case 'kryptomon_defeated':
      hapticFeedback('heavy');
      console.log('üíÄ Kryptomon defeated!');
      break;
    case 'kryptomon_switch':
      hapticFeedback('light');
      console.log('üîÑ Kryptomon switched!');
      break;
    case 'game_over':
      hapticFeedback('success');
      console.log('üèÅ Game over!');
      break;
  }
}

// Placeholder functions
function playSound(soundName) {
  console.log('üîä Playing sound:', soundName);
  // TODO: Implement actual sound playing
}

function showMessage(message, type) {
  console.log('üí¨ Message:', message, type);
  // TODO: Implement message display
}

// Team switching function
function switchKryptomon(index) {
  console.log('üîÑ Switching to Kryptomon:', index);
  
  if (!gameState.socket || !gameState.inGame) {
    console.log('‚ùå Cannot switch: not in game');
    hapticFeedback('error');
    return;
  }

  if (!gameState.connected) {
    console.log('‚ùå Cannot switch: not connected');
    hapticFeedback('error');
    return;
  }

  if (!gameState.yourTurn) {
    console.log('‚ùå Cannot switch: not your turn');
    hapticFeedback('error');
    return;
  }

  // Validate switch locally
  if (!gameState.gameData || gameState.yourIndex === null) {
    console.log('‚ùå Cannot switch: no game data');
    hapticFeedback('error');
    return;
  }

  const yourData = gameState.gameData.players[gameState.yourIndex];
  if (!yourData || !yourData.team[index]) {
    console.log('‚ùå Cannot switch: invalid kryptomon index');
    hapticFeedback('error');
    return;
  }

  if (!yourData.team[index].isAlive) {
    console.log('‚ùå Cannot switch: kryptomon is defeated');
    hapticFeedback('error');
    return;
  }

  if (index === yourData.currentKryptomon) {
    console.log('‚ùå Cannot switch: already using this kryptomon');
    hapticFeedback('light');
    return;
  }

  try {
    gameState.socket.emit('requestTeamSwitch', {
      kryptomonIndex: index
    });
    
    hapticFeedback('light');
    
  } catch (error) {
    console.error('‚ùå Switch request failed:', error);
    hapticFeedback('error');
  }
}

// Battle move function
function performBattleMove(moveType) {
  console.log('‚öîÔ∏è Performing move:', moveType);
  
  if (!gameState.connected || !gameState.socket) {
    hapticFeedback('error');
    return;
  }

  if (!gameState.inGame) {
    hapticFeedback('error');
    return;
  }

  if (!gameState.yourTurn) {
    hapticFeedback('error');
    return;
  }

  try {
    // Disable buttons temporarily
    const buttons = document.querySelectorAll('.control-btn');
    buttons.forEach(btn => btn.disabled = true);
    
    gameState.socket.emit('battleMove', {
      move: moveType
    });
    
    hapticFeedback('medium');
    
    // Re-enable buttons after delay
    setTimeout(() => {
      buttons.forEach(btn => btn.disabled = false);
      updateButtons(); // Apply proper button states
    }, 1000);
    
  } catch (error) {
    console.error('‚ùå Battle move failed:', error);
    hapticFeedback('error');
    
    // Re-enable buttons on error
    const buttons = document.querySelectorAll('.control-btn');
    buttons.forEach(btn => btn.disabled = false);
  }
}

// Start game function
function startGame() {
  const nameInput = document.getElementById('playerName');
  if (nameInput && nameInput.value.trim()) {
    gameState.playerName = nameInput.value.trim();
  }
  
  console.log('üéÆ Starting game as:', gameState.playerName);
  hapticFeedback('light');
  connectToServer();
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
  console.log('üöÄ Page loaded, initializing...');
  showScreen('start-screen');
  
  // Auto-fill Telegram name if available
  if (gameState.playerName !== 'Anonymous') {
    const nameInput = document.getElementById('playerName');
    if (nameInput) {
      nameInput.value = gameState.playerName;
    }
  }
  
  // Auto-start for Telegram users
  if (isTelegramWebApp) {
    setTimeout(() => {
      startGame();
    }, 1000);
  }
});
</script>
</head>

<body>
  <!-- Start Screen -->
  <div id="start-screen" class="screen">
    <div class="start-container">
      <h1>üêæ Kryptomon Battle Arena</h1>
      <p class="subtitle">Epic NFT Battles Await!</p>
      <input type="text" id="playerName" placeholder="Enter your name" maxlength="20" />
      <button id="start-btn" onclick="startGame()">‚öîÔ∏è Start Battle</button>
      <div class="features">
        <div>üéØ Defeat 3 enemy Kryptomon</div>
        <div>‚ö° Real-time multiplayer</div>
        <div>üéÆ Strategic combat</div>
      </div>
    </div>
  </div>

  <!-- Waiting Screen -->
  <div id="waiting-screen" class="screen hidden">
    <div class="waiting-container">
      <h2>üîç Finding Opponent</h2>
      <div class="spinner"></div>
      <div id="waiting-message">Searching for worthy opponent...</div>
      <div id="players-count">Players online: 0</div>
    </div>
  </div>

  <!-- Game Screen -->
  <div id="game-screen" class="screen hidden">
    <!-- Game Header -->
    <div class="game-header">
      <div id="status" class="status">Waiting...</div>
    </div>

    <!-- Main Battle Area -->
    <div class="battle-arena">
      <!-- Enemy Area -->
      <div class="enemy-area">
        <div class="enemy-stats">
          <div class="stat-bar">
            <div class="hp-bar">
              <div class="hp-fill"></div>
              <span class="hp-text">100/100</span>
            </div>
            <div class="mp-bar">
              <div class="mp-fill"></div>
              <span class="mp-text">0/100</span>
            </div>
          </div>
        </div>
        <div class="kryptomon enemy">
          <img src="kryptomon1.png" alt="Enemy Kryptomon" />
        </div>
      </div>

      <!-- VS Indicator -->
      <div class="vs-indicator">‚öîÔ∏è VS ‚öîÔ∏è</div>

      <!-- Your Area -->
      <div class="your-area">
        <div class="kryptomon yours">
          <img src="kryptomon1.png" alt="Your Kryptomon" />
        </div>
        <div class="your-stats">
          <div class="stat-bar">
            <div class="hp-bar">
              <div class="hp-fill"></div>
              <span class="hp-text">100/100</span>
            </div>
            <div class="mp-bar">
              <div class="mp-fill"></div>
              <span class="mp-text">0/100</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Team Display -->
    <div class="team-display">
      <!-- Enemy Team -->
      <div class="enemy-team">
        <h3>Enemy Team</h3>
        <div class="team-slots">
          <div class="team-slot">
            <img src="kryptomon1.png" alt="Enemy 1" />
            <div class="hp-indicator"></div>
          </div>
          <div class="team-slot">
            <img src="kryptomon2.png" alt="Enemy 2" />
            <div class="hp-indicator"></div>
          </div>
          <div class="team-slot">
            <img src="kryptomon3.png" alt="Enemy 3" />
            <div class="hp-indicator"></div>
          </div>
        </div>
      </div>

      <!-- Your Team -->
      <div class="your-team">
        <h3>Your Team</h3>
        <div class="team-slots">
          <div class="team-slot" onclick="switchKryptomon(0)">
            <img src="kryptomon1.png" alt="Your 1" />
            <div class="hp-indicator"></div>
          </div>
          <div class="team-slot" onclick="switchKryptomon(1)">
            <img src="kryptomon2.png" alt="Your 2" />
            <div class="hp-indicator"></div>
          </div>
          <div class="team-slot" onclick="switchKryptomon(2)">
            <img src="kryptomon3.png" alt="Your 3" />
            <div class="hp-indicator"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Battle Controls -->
    <div class="battle-controls">
      <button id="attack-btn" class="control-btn attack" onclick="performBattleMove('attack')">
        <img src="attack.png" alt="Attack" />
        <span>Attack</span>
      </button>
      <button id="defend-btn" class="control-btn defend" onclick="performBattleMove('defend')">
        <img src="defence.png" alt="Defend" />
        <span>Defend</span>
      </button>
      <button id="skill-btn" class="control-btn skill" onclick="performBattleMove('skill')">
        <img src="skill.png" alt="Skill" />
        <span>Skill (2 MP)</span>
      </button>
      <button id="ultimate-btn" class="control-btn ultimate" onclick="performBattleMove('ultimate')">
        <img src="hydra.png" alt="Ultimate" />
        <span>Ultimate (6 MP)</span>
      </button>
    </div>
  </div>

  <!-- Damage Text Container -->
  <div id="damage-text-container"></div>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    height: 100vh;
    overflow: hidden;
    position: fixed;
    width: 100%;
    -webkit-font-smoothing: antialiased;
  }

  /* Connection Status */
  .connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    z-index: 1000;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }

  .connection-status.connecting {
    background: rgba(52, 152, 219, 0.9);
    animation: pulse 1.5s infinite;
  }

  .connection-status.connected {
    background: rgba(46, 204, 113, 0.9);
  }

  .connection-status.disconnected {
    background: rgba(231, 76, 60, 0.9);
    animation: shake 0.5s ease-in-out;
  }

  .connection-status.reconnecting {
    background: rgba(241, 196, 15, 0.9);
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.05); }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }

  .screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    padding: 20px;
    transition: opacity 0.3s ease;
  }

  .hidden {
    display: none !important;
  }

  /* Start Screen */
  #start-screen {
    background: rgba(0,0,0,0.95);
    text-align: center;
  }

  .start-container h1 {
    font-size: clamp(2rem, 5vw, 3rem);
    margin-bottom: 20px;
    color: #FFD700;
    text-shadow: 0 0 20px rgba(255,215,0,0.5);
    animation: glow 2s ease-in-out infinite alternate;
  }

  @keyframes glow {
    from { text-shadow: 0 0 20px rgba(255,215,0,0.5); }
    to { text-shadow: 0 0 30px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.3); }
  }

  .subtitle {
    font-size: 1.2rem;
    margin-bottom: 30px;
    color: rgba(255,255,255,0.8);
  }

  #start-screen input {
    padding: 15px;
    font-size: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 25px;
    margin: 10px 0;
    width: 90%;
    max-width: 300px;
    text-align: center;
    background: rgba(255,255,255,0.1);
    color: white;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }

  #start-screen input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
  }

  #start-screen input::placeholder {
    color: rgba(255,255,255,0.7);
  }

  #start-screen button {
    padding: 15px 30px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    border-radius: 25px;
    margin: 10px;
    cursor: pointer;
    width: 90%;
    max-width: 300px;
    transition: all 0.3s ease;
    background: linear-gradient(135deg, #2ecc71, #27ae60);
    color: white;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
  }

  #start-screen button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
  }

  .features {
    margin-top: 30px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    font-size: 14px;
    color: rgba(255,255,255,0.7);
  }

  /* Waiting Screen */
  #waiting-screen {
    background: rgba(0,0,0,0.95);
    text-align: center;
  }

  .waiting-container h2 {
    font-size: 2rem;
    margin-bottom: 30px;
    color: #3498db;
  }

  .spinner {
    width: 60px;
    height: 60px;
    border: 4px solid rgba(255,255,255,0.3);
    border-top: 4px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 20px auto;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  #waiting-message, #players-count {
    font-size: 1.1rem;
    margin: 10px 0;
    color: rgba(255,255,255,0.8);
  }

  /* Game Screen */
  #game-screen {
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    padding: 10px;
    overflow-y: auto;
  }

  .game-header {
    text-align: center;
    margin-bottom: 20px;
  }

  .status {
    font-size: 1.5rem;
    font-weight: bold;
    color: #FFD700;
    text-shadow: 0 0 10px rgba(255,215,0,0.5);
  }

  /* Battle Arena */
  .battle-arena {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    height: 40vh;
    margin: 20px 0;
  }

  .enemy-area, .your-area {
    display: flex;
    align-items: center;
    gap: 20px;
    width: 100%;
    justify-content: center;
  }

  .kryptomon {
    position: relative;
  }

  .kryptomon img {
    width: 120px;
    height: 120px;
    object-fit: contain;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
    transition: all 0.3s ease;
  }

  .kryptomon.attacking img {
    animation: attack 0.5s ease-in-out;
  }

  .kryptomon.defending img {
    animation: defend 0.5s ease-in-out;
  }

  .kryptomon.skill img {
    animation: skill 0.7s ease-in-out;
  }

  .kryptomon.ultimate img {
    animation: ultimate 1s ease-in-out;
  }

  @keyframes attack {
    0%, 100% { transform: translateX(0); }
    50% { transform: translateX(10px) scale(1.1); }
  }

  @keyframes defend {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); filter: brightness(1.3); }
  }

  @keyframes skill {
    0%, 100% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(-10deg) scale(1.1); }
    75% { transform: rotate(10deg) scale(1.1); }
  }

  @keyframes ultimate {
    0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
    50% { transform: scale(1.3); filter: hue-rotate(180deg) brightness(1.5); }
  }

  .vs-indicator {
    font-size: 1.5rem;
    font-weight: bold;
    color: #e74c3c;
    text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
    animation: pulse 2s infinite;
  }

  /* Stat Bars */
  .stat-bar {
    display: flex;
    flex-direction: column;
    gap: 5px;
    min-width: 120px;
  }

  .hp-bar, .mp-bar {
    position: relative;
    height: 20px;
    background: rgba(255,255,255,0.2);
    border-radius: 10px;
    overflow: hidden;
    border: 1px solid rgba(255,255,255,0.3);
  }

  .hp-fill {
    height: 100%;
    background: linear-gradient(90deg, #e74c3c, #c0392b);
    width: 100%;
    transition: width 0.5s ease;
  }

  .mp-fill {
    height: 100%;
    background: linear-gradient(90deg, #3498db, #2980b9);
    width: 0%;
    transition: width 0.5s ease;
  }

  .hp-text, .mp-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
  }

  /* Team Display */
  .team-display {
    display: flex;
    justify-content: space-between;
    margin: 20px 0;
    gap: 20px;
  }

  .enemy-team, .your-team {
    flex: 1;
    text-align: center;
  }

  .enemy-team h3, .your-team h3 {
    margin-bottom: 10px;
    font-size: 1.1rem;
    color: rgba(255,255,255,0.9);
  }

  .team-slots {
    display: flex;
    gap: 10px;
    justify-content: center;
  }

  .team-slot {
    width: 60px;
    height: 60px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    background: rgba(255,255,255,0.1);
  }

  .team-slot img {
    width: 50px;
    height: 50px;
    object-fit: contain;
  }

  .team-slot.active {
    border-color: #f39c12;
    box-shadow: 0 0 15px rgba(243, 156, 18, 0.5);
    background: rgba(243, 156, 18, 0.2);
  }

  .team-slot.dead {
    opacity: 0.3;
    border-color: #e74c3c;
    background: rgba(231, 76, 60, 0.2);
    cursor: not-allowed;
  }

  .team-slot:hover:not(.dead) {
    border-color: #3498db;
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
  }

  /* Battle Controls */
  .battle-controls {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 20px;
    max-width: 400px;
    width: 100%;
  }

  .control-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    padding: 15px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 15px;
    background: rgba(255,255,255,0.1);
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    font-size: 14px;
    font-weight: bold;
  }

  .control-btn img {
    width: 30px;
    height: 30px;
    filter: brightness(1.2);
  }

  .control-btn:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }

  .control-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .control-btn.attack:hover:not(:disabled) {
    border-color: #e74c3c;
    background: rgba(231, 76, 60, 0.2);
    box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
  }

  .control-btn.defend:hover:not(:disabled) {
    border-color: #3498db;
    background: rgba(52, 152, 219, 0.2);
    box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
  }

  .control-btn.skill:hover:not(:disabled) {
    border-color: #9b59b6;
    background: rgba(155, 89, 182, 0.2);
    box-shadow: 0 5px 15px rgba(155, 89, 182, 0.3);
  }

  .control-btn.ultimate:hover:not(:disabled) {
    border-color: #f39c12;
    background: rgba(243, 156, 18, 0.2);
    box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
  }

  /* Damage Text */
  .damage-text {
    position: fixed;
    font-weight: bold;
    font-size: 24px;
    z-index: 1000;
    animation: damageFloat 2s ease-out forwards;
    pointer-events: none;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  }

  .damage-text.damage {
    color: #e74c3c;
  }

  .damage-text.critical {
    color: #f39c12;
    font-size: 32px;
    animation: criticalFloat 2s ease-out forwards;
  }

  .damage-text.heal {
    color: #2ecc71;
  }

  @keyframes damageFloat {
    0% {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    100% {
      opacity: 0;
      transform: translateY(-50px) scale(1.2);
    }
  }

  @keyframes criticalFloat {
    0% {
      opacity: 1;
      transform: translateY(0) scale(1.5);
    }
    50% {
      transform: translateY(-25px) scale(2) rotate(10deg);
    }
    100% {
      opacity: 0;
      transform: translateY(-60px) scale(2.5) rotate(-10deg);
    }
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .battle-controls {
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    
    .control-btn {
      padding: 10px;
      font-size: 12px;
    }
    
    .control-btn img {
      width: 25px;
      height: 25px;
    }
    
    .team-slot {
      width: 50px;
      height: 50px;
    }
    
    .team-slot img {
      width: 40px;
      height: 40px;
    }
    
    .kryptomon img {
      width: 100px;
      height: 100px;
    }
    
    .stat-bar {
      min-width: 100px;
    }
    
    .team-display {
      flex-direction: column;
      gap: 15px;
    }
    
    .battle-arena {
      height: 35vh;
    }
  }

  @media (max-width: 480px) {
    .battle-controls {
      gap: 6px;
    }
    
    .control-btn {
      padding: 8px;
      font-size: 11px;
    }
    
    .control-btn img {
      width: 20px;
      height: 20px;
    }
    
    .kryptomon img {
      width: 80px;
      height: 80px;
    }
    
    .team-slot {
      width: 45px;
      height: 45px;
    }
    
    .team-slot img {
      width: 35px;
      height: 35px;
    }
  }
</style>

</body>
</html>
