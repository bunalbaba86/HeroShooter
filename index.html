<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Kryptomon Battle Arena</title>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<script>
// Enhanced Telegram WebApp integration
const tg = window.Telegram?.WebApp;
const isTelegramWebApp = !!tg;

// Global game state with enhanced management
const gameState = {
  connected: false,
  socket: null,
  inGame: false,
  gameData: null,
  yourIndex: null,
  yourTurn: false,
  playerName: 'Anonymous',
  telegramUserId: null,
  connectionAttempts: 0,
  lastConnectionError: null,
  reconnectTimeout: null,
  gameBackup: null
};

// Enhanced connection status tracking
const connectionStatus = {
  element: null,
  lastUpdate: Date.now(),
  retryCount: 0,
  maxRetries: 5
};

if (tg) {
  console.log('üì± Telegram WebApp detected');
  tg.ready();
  tg.expand();
  
  // Get user info from Telegram
  const user = tg.initDataUnsafe?.user;
  if (user) {
    gameState.playerName = user.first_name || user.username || 'Player';
    gameState.telegramUserId = user.id;
    console.log('üë§ Telegram user:', gameState.playerName);
  }
  
  // Enhanced haptic feedback
  function hapticFeedback(type = 'medium') {
    try {
      if (tg.HapticFeedback) {
        switch(type) {
          case 'light':
            tg.HapticFeedback.impactOccurred('light');
            break;
          case 'medium':
            tg.HapticFeedback.impactOccurred('medium');
            break;
          case 'heavy':
          case 'error':
            tg.HapticFeedback.impactOccurred('heavy');
            break;
          case 'success':
            tg.HapticFeedback.notificationOccurred('success');
            break;
          case 'warning':
            tg.HapticFeedback.notificationOccurred('warning');
            break;
        }
      }
    } catch (error) {
      console.error('Haptic feedback error:', error);
    }
  }
  
  // Show main button after game
  function showMainButton(text, callback) {
    try {
      tg.MainButton.text = text;
      tg.MainButton.show();
      tg.MainButton.onClick(callback);
    } catch (error) {
      console.error('Main button error:', error);
    }
  }
} else {
  // Fallback haptic function for non-Telegram
  function hapticFeedback(type = 'medium') {
    if (navigator.vibrate) {
      switch(type) {
        case 'light':
          navigator.vibrate(50);
          break;
        case 'medium':
          navigator.vibrate(100);
          break;
        case 'heavy':
        case 'error':
          navigator.vibrate([100, 50, 100]);
          break;
        case 'success':
          navigator.vibrate([50, 50, 50]);
          break;
      }
    }
  }
  
  function showMainButton() {
    // No-op for non-Telegram
  }
}

// Screen management function
function showScreen(screenId) {
  console.log('üñ•Ô∏è Showing screen:', screenId);
  
  // Hide all screens
  const screens = document.querySelectorAll('.screen');
  screens.forEach(screen => {
    screen.classList.add('hidden');
  });
  
  // Show target screen
  const targetScreen = document.getElementById(screenId);
  if (targetScreen) {
    targetScreen.classList.remove('hidden');
    console.log('‚úÖ Screen shown:', screenId);
  } else {
    console.error('‚ùå Screen not found:', screenId);
  }
}

// Enhanced connection management
function updateConnectionStatus(status) {
  let statusElement = document.getElementById('connection-status');
  if (!statusElement) {
    // Create status element if it doesn't exist
    statusElement = document.createElement('div');
    statusElement.id = 'connection-status';
    statusElement.className = 'connection-status';
    document.body.appendChild(statusElement);
  }
  
  const now = Date.now();
  connectionStatus.lastUpdate = now;
  
  switch(status) {
    case 'connecting':
      statusElement.textContent = 'üîÑ Connecting...';
      statusElement.className = 'connection-status connecting';
      statusElement.style.display = 'block';
      break;
    case 'connected':
      statusElement.textContent = '‚úÖ Connected';
      statusElement.className = 'connection-status connected';
      statusElement.style.display = 'block';
      connectionStatus.retryCount = 0;
      // Hide after 2 seconds
      setTimeout(() => {
        statusElement.style.display = 'none';
      }, 2000);
      break;
    case 'disconnected':
      statusElement.textContent = '‚ùå Disconnected';
      statusElement.className = 'connection-status disconnected';
      statusElement.style.display = 'block';
      break;
    case 'reconnecting':
      statusElement.textContent = `üîÑ Reconnecting... (${connectionStatus.retryCount}/${connectionStatus.maxRetries})`;
      statusElement.className = 'connection-status reconnecting';
      statusElement.style.display = 'block';
      break;
  }
}

// Enhanced game state backup/restore
function backupGameState() {
  if (gameState.inGame && gameState.gameData) {
    try {
      const backup = {
        gameData: gameState.gameData,
        yourIndex: gameState.yourIndex,
        playerName: gameState.playerName,
        telegramUserId: gameState.telegramUserId,
        timestamp: Date.now()
      };
      localStorage.setItem('kryptomon_game_backup', JSON.stringify(backup));
      gameState.gameBackup = backup;
      console.log('üíæ Game state backed up');
    } catch (error) {
      console.error('‚ùå Backup failed:', error);
    }
  }
}

function restoreGameState() {
  try {
    const backup = localStorage.getItem('kryptomon_game_backup');
    if (backup) {
      const data = JSON.parse(backup);
      // Only restore if backup is less than 5 minutes old
      if (Date.now() - data.timestamp < 300000) {
        console.log('üîÑ Restoring game state');
        return data;
      } else {
        console.log('‚è∞ Backup too old, discarding');
        localStorage.removeItem('kryptomon_game_backup');
      }
    }
  } catch (error) {
    console.error('‚ùå Restore failed:', error);
    localStorage.removeItem('kryptomon_game_backup');
  }
  return null;
}

// Enhanced connection with retry logic and fallback
function connectToServer(retryCount = 0) {
  if (retryCount >= connectionStatus.maxRetries) {
    updateConnectionStatus('disconnected');
    if (tg?.showAlert) {
      tg.showAlert('Unable to connect to server. Please check your internet connection and try again.');
    } else {
      alert('Unable to connect to server. Please check your internet connection and try again.');
    }
    return;
  }

  updateConnectionStatus(retryCount === 0 ? 'connecting' : 'reconnecting');
  connectionStatus.retryCount = retryCount;
  
  // Use same domain (Vercel)
  const serverUrl = window.location.origin;
  console.log(`üîå Connecting to server (attempt ${retryCount + 1}):`, serverUrl);
  
  // Clear any existing connection
  if (gameState.socket) {
    gameState.socket.disconnect();
    gameState.socket = null;
  }

  gameState.socket = io(serverUrl, {
    withCredentials: true,
    timeout: 30000,
    transports: ['polling', 'websocket'], // Polling first for stability
    forceNew: true,
    reconnection: true,
    reconnectionAttempts: 3,
    reconnectionDelay: 2000,
    reconnectionDelayMax: 10000,
    maxReconnectionAttempts: 3
  });

  // Enhanced event handlers
  setupSocketEventHandlers();
}

// Enhanced socket event handlers
function setupSocketEventHandlers() {
  if (!gameState.socket) return;

  // Clear existing listeners to prevent duplicates
  gameState.socket.removeAllListeners();

  // Connection success
  gameState.socket.on('connect', () => {
    console.log('‚úÖ Connected to server successfully');
    gameState.connected = true;
    gameState.connectionAttempts = 0;
    updateConnectionStatus('connected');
    
    // Clear any reconnect timeout
    if (gameState.reconnectTimeout) {
      clearTimeout(gameState.reconnectTimeout);
      gameState.reconnectTimeout = null;
    }
    
    // Enable UI
    enableGameUI();
    
    // Try to restore game state or join new game
    const backup = restoreGameState();
    if (backup && !gameState.inGame) {
      console.log('üîÑ Attempting to restore game state');
      hapticFeedback('light');
    }
  });

  // Connection error handling
  gameState.socket.on('connect_error', (error) => {
    console.error('‚ùå Connection error:', error);
    gameState.connected = false;
    gameState.lastConnectionError = error;
    
    // Retry with exponential backoff
    const delay = Math.min(Math.pow(2, connectionStatus.retryCount) * 1000, 10000);
    console.log(`üîÑ Retrying connection in ${delay}ms...`);
    
    gameState.reconnectTimeout = setTimeout(() => {
      connectToServer(connectionStatus.retryCount + 1);
    }, delay);
  });

  // Disconnection handling
  gameState.socket.on('disconnect', (reason) => {
    console.log('‚ùå Disconnected:', reason);
    gameState.connected = false;
    updateConnectionStatus('disconnected');
    
    // Backup current game state
    backupGameState();
    
    // Disable UI elements
    disableGameUI();
    
    // Auto-reconnect logic
    if (reason !== 'io server disconnect') {
      console.log('üîÑ Attempting auto-reconnect...');
      gameState.reconnectTimeout = setTimeout(() => {
        connectToServer(0);
      }, 3000);
    }
  });

  // Reconnection events
  gameState.socket.on('reconnect', (attemptNumber) => {
    console.log('‚úÖ Reconnected after', attemptNumber, 'attempts');
    updateConnectionStatus('connected');
    hapticFeedback('success');
    enableGameUI();
  });

  gameState.socket.on('reconnect_error', (error) => {
    console.error('‚ùå Reconnection failed:', error);
  });

  gameState.socket.on('reconnect_failed', () => {
    console.error('‚ùå All reconnection attempts failed');
    updateConnectionStatus('disconnected');
    if (tg?.showAlert) {
      tg.showAlert('Connection lost. Please restart the game.');
    }
  });

  // GAME EVENT HANDLERS
  
  // Waiting for opponent
  gameState.socket.on('waitingForOpponent', (data) => {
    console.log('‚è≥ Waiting for opponent...', data);
    showScreen('waiting-screen');
    
    const waitingMessage = document.getElementById('waiting-message');
    if (waitingMessage) {
      waitingMessage.textContent = data.message || 'Finding opponent...';
    }
    
    const playersCount = document.getElementById('players-count');
    if (playersCount && data.playersWaiting !== undefined) {
      playersCount.textContent = `Players waiting: ${data.playersWaiting}`;
    }
  });

  // Game started
  gameState.socket.on('gameStarted', (data) => {
    console.log('üéÆ Game started!', data);
    try {
      gameState.inGame = true;
      gameState.gameData = data.gameRoom;
      gameState.yourIndex = data.yourIndex;
      gameState.yourTurn = data.gameRoom.currentTurn === data.yourIndex;
      
      console.log('üë§ Your index:', gameState.yourIndex);
      console.log('üéØ Your turn:', gameState.yourTurn);
      console.log('üéÆ Game room:', data.gameRoom);
      
      showScreen('game-screen');
      updateUI(data.gameRoom);
      hapticFeedback('success');
      
      // Clear any backup since we have fresh game state
      localStorage.removeItem('kryptomon_game_backup');
      
    } catch (error) {
      console.error('‚ùå Game start error:', error);
      if (tg?.showAlert) {
        tg.showAlert('Failed to start game. Please try again.');
      } else {
        alert('Failed to start game. Please try again.');
      }
    }
  });

  // Move result
  gameState.socket.on('moveResult', (data) => {
    console.log('‚öîÔ∏è Move result:', data);
    try {
      gameState.gameData = data.gameRoom;
      gameState.yourTurn = data.gameRoom.currentTurn === gameState.yourIndex;
      
      processMoveResult(data.moveResult);
      updateUI(data.gameRoom);
      
      // Play sound effect
      if (data.moveResult.soundEffect) {
        playSound(data.moveResult.soundEffect);
      }
      
      // Show damage text
      if (data.moveResult.damageInfo) {
        showDamageText(data.moveResult.damageInfo);
      }
      
      backupGameState();
      
    } catch (error) {
      console.error('‚ùå Move result error:', error);
    }
  });

  // Team switched
  gameState.socket.on('teamSwitched', (data) => {
    console.log('‚úÖ Team switched:', data);
    try {
      if (data.success) {
        gameState.gameData = data.gameRoom;
        updateUI(data.gameRoom);
        
        if (data.playerIndex === gameState.yourIndex) {
          hapticFeedback('success');
          showMessage('‚úÖ Kryptomon switched!', 'success');
        }
        
        updateTeamDisplay();
        backupGameState();
      }
    } catch (error) {
      console.error('‚ùå Team switch error:', error);
    }
  });

  // Game over
  gameState.socket.on('gameOver', (data) => {
    console.log('üèÅ Game over:', data);
    gameState.inGame = false;
    gameState.gameData = null;
    
    // Clear backup
    localStorage.removeItem('kryptomon_game_backup');
    
    const isWinner = data.winner === gameState.yourIndex;
    
    if (isWinner) {
      hapticFeedback('success');
      if (tg?.showAlert) {
        tg.showAlert('üèÜ Victory! You defeated all enemy Kryptomon!');
      } else {
        alert('üèÜ Victory! You defeated all enemy Kryptomon!');
      }
    } else {
      hapticFeedback('error');
      if (tg?.showAlert) {
        tg.showAlert('üíÄ Defeat! Your team has fallen!');
      } else {
        alert('üíÄ Defeat! Your team has fallen!');
      }
    }
    
    setTimeout(() => {
      showScreen('start-screen');
    }, 3000);
  });

  // Opponent disconnected
  gameState.socket.on('opponentDisconnected', (data) => {
    console.log('üíî Opponent disconnected:', data);
    hapticFeedback('warning');
    
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚è≥ Opponent disconnected, waiting...';
    }
    
    if (data.waitingForReconnect) {
      setTimeout(() => {
        if (tg?.showAlert) {
          tg.showAlert('Opponent left the game. Returning to main menu.');
        } else {
          alert('Opponent left the game. Returning to main menu.');
        }
        showScreen('start-screen');
        gameState.inGame = false;
        gameState.gameData = null;
      }, 30000); // Wait 30 seconds for reconnect
    }
  });

  // Enhanced error handling
  gameState.socket.on('error', (error) => {
    console.error('üö® Socket error:', error);
    hapticFeedback('error');
    
    const status = document.getElementById('status');
    if (status && gameState.inGame) {
      // Show user-friendly error message
      if (error.message.includes('team switch')) {
        status.textContent = '‚ùå ' + error.message;
      } else if (error.message.includes('turn')) {
        status.textContent = '‚ùå Not your turn!';
      } else if (error.message.includes('mana')) {
        status.textContent = '‚ùå Not enough mana!';
      } else if (error.message.includes('cooldown')) {
        status.textContent = '‚ùå Skill on cooldown!';
      } else {
        status.textContent = '‚ùå ' + (error.message || 'Action failed');
      }
      
      // Reset status after 3 seconds
      setTimeout(() => {
        if (gameState.inGame) {
          status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
        }
      }, 3000);
    }
  });

  // Game info
  gameState.socket.on('gameInfo', (data) => {
    console.log('‚ÑπÔ∏è Game info:', data);
  });

  // Network quality monitoring
  setInterval(() => {
    if (gameState.connected && gameState.socket) {
      const startTime = Date.now();
      gameState.socket.emit('ping', startTime);
      
      gameState.socket.once('pong', (timestamp) => {
        const latency = Date.now() - timestamp;
        console.log(`üèì Latency: ${latency}ms`);
        
        // Show latency warning for high ping
        if (latency > 1000) {
          const status = document.getElementById('status');
          if (status && gameState.inGame) {
            status.textContent = `‚ö†Ô∏è High latency: ${latency}ms`;
            setTimeout(() => {
              status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
            }, 2000);
          }
        }
      });
    }
  }, 30000); // Check every 30 seconds
}

// UI state management
function enableGameUI() {
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(btn => {
    btn.disabled = false;
    btn.style.opacity = '1';
    btn.style.pointerEvents = 'auto';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'auto';
    slot.style.opacity = '1';
  });
}

function disableGameUI() {
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(btn => {
    btn.disabled = true;
    btn.style.opacity = '0.5';
    btn.style.pointerEvents = 'none';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'none';
    slot.style.opacity = '0.5';
  });
}

// Game functions
function startGame() {
  console.log('üéÆ Starting game...');
  
  const nameInput = document.getElementById('playerName');
  if (nameInput && nameInput.value.trim()) {
    gameState.playerName = nameInput.value.trim();
  }
  
  console.log('üë§ Player name:', gameState.playerName);
  
  if (!gameState.connected) {
    connectToServer();
  } else {
    // Already connected, just join game
    joinGame();
  }
}

function joinGame() {
  if (!gameState.socket || !gameState.connected) {
    console.log('‚ùå Cannot join game: not connected');
    return;
  }
  
  console.log('üéÆ Joining game...');
  
  gameState.socket.emit('joinGame', {
    username: gameState.playerName,
    telegramUserId: gameState.telegramUserId,
    isTelegramUser: isTelegramWebApp
  });
}

// Enhanced team switching with comprehensive validation
function switchKryptomon(index) {
  console.log('üîÑ Switching to Kryptomon:', index);
  
  if (!gameState.socket || !gameState.inGame) {
    console.log('‚ùå Cannot switch: not in game');
    hapticFeedback('error');
    return;
  }

  if (!gameState.connected) {
    console.log('‚ùå Cannot switch: not connected');
    hapticFeedback('error');
    showMessage('‚ùå Not connected to server!', 'error');
    return;
  }

  if (!gameState.yourTurn) {
    console.log('‚ùå Cannot switch: not your turn');
    hapticFeedback('error');
    showMessage('‚ùå Can only switch during your turn!', 'error');
    return;
  }

  // Validate the switch locally first
  if (!gameState.gameData || gameState.yourIndex === null) {
    console.log('‚ùå Cannot switch: no game data');
    hapticFeedback('error');
    return;
  }

  const yourData = gameState.gameData.players[gameState.yourIndex];
  if (!yourData || !yourData.team[index]) {
    console.log('‚ùå Cannot switch: invalid kryptomon index');
    hapticFeedback('error');
    return;
  }

  if (!yourData.team[index].isAlive) {
    console.log('‚ùå Cannot switch: kryptomon is defeated');
    hapticFeedback('error');
    showMessage('‚ùå Cannot switch to defeated Kryptomon!', 'error');
    return;
  }

  if (index === yourData.currentKryptomon) {
    console.log('‚ùå Cannot switch: already using this kryptomon');
    hapticFeedback('light');
    return;
  }

  // Send switch request
  try {
    gameState.socket.emit('requestTeamSwitch', {
      kryptomonIndex: index
    });
    
    hapticFeedback('light');
    showMessage('üîÑ Switching Kryptomon...', 'info');
    
  } catch (error) {
    console.error('‚ùå Switch request failed:', error);
    hapticFeedback('error');
  }
}

// Enhanced battle move with validation
function performBattleMove(moveType) {
  console.log('‚öîÔ∏è Performing move:', moveType);
  
  if (!gameState.connected || !gameState.socket) {
    hapticFeedback('error');
    showMessage('‚ùå Not connected!', 'error');
    return;
  }

  if (!gameState.inGame) {
    hapticFeedback('error');
    return;
  }

  if (!gameState.yourTurn) {
    hapticFeedback('error');
    showMessage('‚ùå Not your turn!', 'error');
    return;
  }

  // Local validation based on current state
  if (gameState.gameData && gameState.yourIndex !== null) {
    const yourData = gameState.gameData.players[gameState.yourIndex];
    const currentKryptomon = yourData.team[yourData.currentKryptomon];
    
    if (!currentKryptomon.isAlive) {
      hapticFeedback('error');
      return;
    }

    // Check mana requirements
    const moves = {
      attack: { manaCost: 0 },
      defend: { manaCost: 0 },
      skill: { manaCost: 2 },
      ultimate: { manaCost: 6 }
    };

    const move = moves[moveType];
    if (move && move.manaCost > currentKryptomon.mana) {
      hapticFeedback('error');
      showMessage('‚ùå Not enough mana!', 'error');
      return;
    }

    // Check ultimate usage
    if (moveType === 'ultimate' && currentKryptomon.ultimateUsed) {
      hapticFeedback('error');
      showMessage('‚ùå Ultimate already used!', 'error');
      return;
    }

    // Check defend cooldown
    if (moveType === 'defend' && yourData.defendCooldown > 0) {
      hapticFeedback('error');
      showMessage(`‚ùå Defend on cooldown (${yourData.defendCooldown} turns)!`, 'error');
      return;
    }
  }

  try {
    // Disable buttons to prevent double-clicks
    const buttons = document.querySelectorAll('.control-btn');
    buttons.forEach(btn => btn.disabled = true);
    
    gameState.socket.emit('battleMove', {
      move: moveType
    });
    
    hapticFeedback('medium');
    
    // Re-enable buttons after a delay
    setTimeout(() => {
      buttons.forEach(btn => btn.disabled = false);
    }, 1000);
    
  } catch (error) {
    console.error('‚ùå Battle move failed:', error);
    hapticFeedback('error');
    
    // Re-enable buttons on error
    const buttons = document.querySelectorAll('.control-btn');
    buttons.forEach(btn => btn.disabled = false);
  }
}

// UI Update functions
function updateUI(gameRoom) {
  console.log('üé® Updating UI with game data:', gameRoom);
  
  if (!gameRoom || gameState.yourIndex === null) return;
  
  try {
    // Update status
    updateStatus();
    
    // Update player stats
    updatePlayerStats(gameRoom);
    
    // Update team displays
    updateTeamDisplay();
    
    // Update control buttons
    updateButtons();
    
    // Update battle arena
    updateBattleArena(gameRoom);
    
  } catch (error) {
    console.error('‚ùå UI update error:', error);
  }
}

function updateStatus() {
  const status = document.getElementById('status');
  if (status) {
    status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
    
    // Add visual indicator
    const yourPanel = document.querySelector('.stat-panel.your');
    const enemyPanel = document.querySelector('.stat-panel.enemy');
    
    if (yourPanel && enemyPanel) {
      yourPanel.classList.toggle('active', gameState.yourTurn);
      enemyPanel.classList.toggle('active', !gameState.yourTurn);
    }
  }
}

function updatePlayerStats(gameRoom) {
  if (!gameRoom || !gameRoom.players) return;
  
  const yourData = gameRoom.players[gameState.yourIndex];
  const enemyData = gameRoom.players[1 - gameState.yourIndex];
  
  if (!yourData || !enemyData) return;
  
  // Update your stats
  updateStatsPanel('.your-stats', yourData);
  
  // Update enemy stats
  updateStatsPanel('.enemy-stats', enemyData);
}

function updateStatsPanel(selector, playerData) {
  const panel = document.querySelector(selector);
  if (!panel || !playerData.team) return;
  
  const currentKryptomon = playerData.team[playerData.currentKryptomon];
  if (!currentKryptomon) return;
  
  // Update HP bar
  const hpFill = panel.querySelector('.hp-fill');
  const hpText = panel.querySelector('.hp-text');
  if (hpFill && hpText) {
    const hpPercent = (currentKryptomon.hp / currentKryptomon.maxHp) * 100;
    hpFill.style.width = `${hpPercent}%`;
    hpText.textContent = `${currentKryptomon.hp}/${currentKryptomon.maxHp}`;
  }
  
  // Update MP bar
  const mpFill = panel.querySelector('.mp-fill');
  const mpText = panel.querySelector('.mp-text');
  if (mpFill && mpText) {
    const mpPercent = (currentKryptomon.mana / currentKryptomon.maxMana) * 100;
    mpFill.style.width = `${mpPercent}%`;
    mpText.textContent = `${currentKryptomon.mana}/${currentKryptomon.maxMana}`;
  }
  
  // Update player name
  const nameElement = panel.querySelector('.player-name');
  if (nameElement) {
    nameElement.textContent = playerData.username;
  }
}

function updateTeamDisplay() {
  if (!gameState.gameData || gameState.yourIndex === null) return;
  
  const yourData = gameState.gameData.players[gameState.yourIndex];
  const enemyData = gameState.gameData.players[1 - gameState.yourIndex];
  
  // Update your team display
  updateTeamSlots('.your-team', yourData);
  
  // Update enemy team display
  updateTeamSlots('.enemy-team', enemyData);
}

function updateTeamSlots(selector, playerData) {
  const teamContainer = document.querySelector(selector);
  if (!teamContainer || !playerData.team) return;
  
  const slots = teamContainer.querySelectorAll('.team-slot');
  slots.forEach((slot, index) => {
    if (!playerData.team[index]) return;
    
    const kryptomon = playerData.team[index];
    
    // Update slot classes
    slot.classList.remove('active', 'dead');
    
    if (kryptomon.isAlive) {
      if (index === playerData.currentKryptomon) {
        slot.classList.add('active');
      }
    } else {
      slot.classList.add('dead');
    }
    
    // Update slot image
    const img = slot.querySelector('img');
    if (img) {
      img.src = `kryptomon${kryptomon.sprite}.png`;
      img.alt = kryptomon.name;
    }
  });
}

function updateButtons() {
  if (!gameState.gameData || gameState.yourIndex === null) return;
  
  const yourData = gameState.gameData.players[gameState.yourIndex];
  const currentKryptomon = yourData.team[yourData.currentKryptomon];
  
  if (!currentKryptomon) return;
  
  // Update button states based on current Kryptomon
  const attackBtn = document.getElementById('attack-btn');
  const defendBtn = document.getElementById('defend-btn');
  const skillBtn = document.getElementById('skill-btn');
  const ultimateBtn = document.getElementById('ultimate-btn');
  
  if (attackBtn) {
    attackBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive;
  }
  
  if (defendBtn) {
    defendBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || yourData.defendCooldown > 0;
    if (yourData.defendCooldown > 0) {
      defendBtn.textContent = `Defend (${yourData.defendCooldown})`;
    } else {
      defendBtn.textContent = 'Defend';
    }
  }
  
  if (skillBtn) {
    skillBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || currentKryptomon.mana < 2;
  }
  
  if (ultimateBtn) {
    ultimateBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || currentKryptomon.mana < 6 || currentKryptomon.ultimateUsed;
  }
}

function updateBattleArena(gameRoom) {
  const yourData = gameRoom.players[gameState.yourIndex];
  const enemyData = gameRoom.players[1 - gameState.yourIndex];
  
  // Update your Kryptomon display
  const yourKryptomon = document.getElementById('your-kryptomon');
  if (yourKryptomon && yourData.team[yourData.currentKryptomon]) {
    const krypto = yourData.team[yourData.currentKryptomon];
    const img = yourKryptomon.querySelector('img');
    if (img) {
      img.src = `kryptomon${krypto.sprite}.png`;
      img.alt = krypto.name;
    }
  }
  
  // Update enemy Kryptomon display
  const enemyKryptomon = document.getElementById('enemy-kryptomon');
  if (enemyKryptomon && enemyData.team[enemyData.currentKryptomon]) {
    const krypto = enemyData.team[enemyData.currentKryptomon];
    const img = enemyKryptomon.querySelector('img');
    if (img) {
      img.src = `kryptomon${krypto.sprite}.png`;
      img.alt = krypto.name;
    }
  }
}

// Move result processing
function processMoveResult(moveResult) {
  console.log('‚öîÔ∏è Processing move result:', moveResult);
  
  // Apply visual effects based on move type
  const yourKryptomon = document.getElementById('your-kryptomon');
  const enemyKryptomon = document.getElementById('enemy-kryptomon');
  
  if (moveResult.playerIndex === gameState.yourIndex) {
    // Your move
    if (yourKryptomon) {
      yourKryptomon.classList.add(moveResult.moveType);
      setTimeout(() => {
        yourKryptomon.classList.remove(moveResult.moveType);
      }, 2000);
    }
  } else {
    // Enemy move
    if (enemyKryptomon) {
      enemyKryptomon.classList.add(moveResult.moveType);
      setTimeout(() => {
        enemyKryptomon.classList.remove(moveResult.moveType);
      }, 2000);
    }
  }
}

// Utility functions
function showMessage(message, type = 'info') {
  console.log(`üí¨ Message (${type}):`, message);
  
  const status = document.getElementById('status');
  if (status) {
    const originalText = status.textContent;
    status.textContent = message;
    
    // Reset after 2 seconds
    setTimeout(() => {
      status.textContent = originalText;
    }, 2000);
  }
}

function showDamageText(damageInfo) {
  console.log('üí• Showing damage text:', damageInfo);
  // Implement damage text animation
}

function playSound(soundName) {
  console.log('üîä Playing sound:', soundName);
  // Implement sound playing
  try {
    const audio = new Audio(`${soundName}.mp3`);
    audio.volume = 0.3;
    audio.play().catch(e => console.log('Sound play failed:', e));
  } catch (error) {
    console.log('Sound error:', error);
  }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
  console.log('üöÄ Page loaded, initializing...');
  showScreen('start-screen');
  
  // Set up event listeners
  setupEventListeners();
});

function setupEventListeners() {
  // Start button
  const startBtn = document.getElementById('start-btn');
  if (startBtn) {
    startBtn.addEventListener('click', startGame);
  }
  
  // Guest button
  const guestBtn = document.getElementById('guest-btn');
  if (guestBtn) {
    guestBtn.addEventListener('click', () => {
      gameState.playerName = 'Guest_' + Math.random().toString(36).substr(2, 5);
      startGame();
    });
  }
  
  // Control buttons
  const attackBtn = document.getElementById('attack-btn');
  if (attackBtn) {
    attackBtn.addEventListener('click', () => performBattleMove('attack'));
  }
  
  const defendBtn = document.getElementById('defend-btn');
  if (defendBtn) {
    defendBtn.addEventListener('click', () => performBattleMove('defend'));
  }
  
  const skillBtn = document.getElementById('skill-btn');
  if (skillBtn) {
    skillBtn.addEventListener('click', () => performBattleMove('skill'));
  }
  
  const ultimateBtn = document.getElementById('ultimate-btn');
  if (ultimateBtn) {
    ultimateBtn.addEventListener('click', () => performBattleMove('ultimate'));
  }
  
  // Team switching (will be handled by event delegation)
  document.addEventListener('click', (e) => {
    if (e.target.closest('.team-slot[data-index]')) {
      const slot = e.target.closest('.team-slot[data-index]');
      const index = parseInt(slot.dataset.index);
      if (!isNaN(index)) {
        switchKryptomon(index);
      }
    }
  });
}
    updateConnectionStatus('disconnected');
    if (tg?.showAlert) {
      tg.showAlert('Unable to connect to server. Please check your internet connection and try again.');
    } else {
      alert('Unable to connect to server. Please check your internet connection and try again.');
    }
    return;
  }

  updateConnectionStatus(retryCount === 0 ? 'connecting' : 'reconnecting');
  connectionStatus.retryCount = retryCount;
  
  // Use same domain (Vercel)
  const serverUrl = window.location.origin;
  console.log(`üîå Connecting to server (attempt ${retryCount + 1}):`, serverUrl);
  
  // Clear any existing connection
  if (gameState.socket) {
    gameState.socket.disconnect();
    gameState.socket = null;
  }

  gameState.socket = io(serverUrl, {
    withCredentials: true,
    timeout: 30000,
    transports: ['polling', 'websocket'], // Polling first for stability
    forceNew: true,
    reconnection: true,
    reconnectionAttempts: 3,
    reconnectionDelay: 2000,
    reconnectionDelayMax: 10000,
    maxReconnectionAttempts: 3,
    pingTimeout: 60000,
    pingInterval: 25000
  });

  // Enhanced game event handlers
  setupGameEventHandlers();
}

// Enhanced game event handlers
function setupGameEventHandlers() {
  if (!gameState.socket) return;

  // Clear existing listeners to prevent duplicates
  gameState.socket.removeAllListeners();

  // Connection events
  gameState.socket.on('connect', () => {
    console.log('‚úÖ Connected to server');
    gameState.connected = true;
    gameState.connectionAttempts = 0;
    updateConnectionStatus('connected');
    
    // Clear any reconnect timeout
    if (gameState.reconnectTimeout) {
      clearTimeout(gameState.reconnectTimeout);
      gameState.reconnectTimeout = null;
    }
    
    // Enable UI
    enableGameUI();
    
    // Join game immediately
    console.log('üéÆ Auto-joining game...');
    gameState.socket.emit('joinGame', {
      username: gameState.playerName,
      telegramUserId: gameState.telegramUserId,
      isTelegramUser: isTelegramWebApp
    });
  });

  gameState.socket.on('connect_error', (error) => {
    console.error('‚ùå Connection error:', error);
    gameState.connected = false;
    gameState.lastConnectionError = error;
    
    // Exponential backoff retry
    const delay = Math.min(Math.pow(2, connectionStatus.retryCount) * 1000, 10000);
    console.log(`üîÑ Retrying connection in ${delay}ms...`);
    
    gameState.reconnectTimeout = setTimeout(() => {
      connectToServer(connectionStatus.retryCount + 1);
    }, delay);
  });

  gameState.socket.on('disconnect', (reason) => {
    console.log('‚ùå Disconnected:', reason);
    gameState.connected = false;
    updateConnectionStatus('disconnected');
    
    // Backup current game state
    backupGameState();
    
    // Disable UI elements
    disableGameUI();
    
    // Auto-reconnect for certain reasons
    if (reason === 'io server disconnect') {
      if (tg?.showAlert) {
        tg.showAlert('Server disconnected. Please restart the game.');
      }
    } else {
      console.log('üîÑ Attempting auto-reconnect...');
      gameState.reconnectTimeout = setTimeout(() => {
        connectToServer(0);
      }, 3000);
    }
  });

  gameState.socket.on('reconnect', (attemptNumber) => {
    console.log('‚úÖ Reconnected after', attemptNumber, 'attempts');
    updateConnectionStatus('connected');
    hapticFeedback('success');
    enableGameUI();
  });

  // Game events
  gameState.socket.on('waitingForOpponent', (data) => {
    console.log('‚è≥ Waiting for opponent...', data);
    showScreen('waiting-screen');
    
    const waitingMessage = document.getElementById('waiting-message');
    if (waitingMessage) {
      waitingMessage.textContent = data.message || 'Finding opponent...';
    }
    
    const spinner = document.querySelector('.spinner');
    if (spinner) {
      spinner.style.display = 'block';
    }
  });

  gameState.socket.on('gameStarted', (data) => {
    console.log('üéÆ Game started!', data);
    try {
      gameState.inGame = true;
      gameState.gameData = data.gameRoom;
      gameState.yourIndex = data.yourIndex;
      gameState.yourTurn = data.gameRoom.currentTurn === data.yourIndex;
      
      console.log('üë§ Your index:', gameState.yourIndex);
      console.log('üéØ Your turn:', gameState.yourTurn);
      
      showScreen('game-screen');
      updateUI(data.gameRoom);
      hapticFeedback('success');
      
      // Clear backup
      localStorage.removeItem('kryptomon_game_backup');
      
    } catch (error) {
      console.error('‚ùå Game start error:', error);
      if (tg?.showAlert) {
        tg.showAlert('Failed to start game. Please try again.');
      } else {
        alert('Failed to start game. Please try again.');
      }
    }
  });

  gameState.socket.on('moveResult', (data) => {
    console.log('‚öîÔ∏è Move result:', data);
    try {
      gameState.gameData = data.gameRoom;
      gameState.yourTurn = data.gameRoom.currentTurn === gameState.yourIndex;
      
      processMoveResult(data.moveResult);
      updateUI(data.gameRoom);
      backupGameState();
      
    } catch (error) {
      console.error('‚ùå Move result error:', error);
    }
  });

  gameState.socket.on('teamSwitched', (data) => {
    console.log('‚úÖ Team switched:', data);
    try {
      if (data.success) {
        gameState.gameData = data.gameRoom;
        updateUI(data.gameRoom);
        
        if (data.playerIndex === gameState.yourIndex) {
          hapticFeedback('success');
          showMessage('‚úÖ Kryptomon switched!', 'success');
        }
        
        updateTeamDisplay();
        backupGameState();
      }
    } catch (error) {
      console.error('‚ùå Team switch error:', error);
    }
  });

  gameState.socket.on('gameOver', (data) => {
    console.log('üèÅ Game over:', data);
    gameState.inGame = false;
    gameState.gameData = null;
    
    localStorage.removeItem('kryptomon_game_backup');
    
    const isWinner = data.winner === gameState.yourIndex;
    
    if (isWinner) {
      hapticFeedback('success');
      if (tg?.showAlert) {
        tg.showAlert('üèÜ Victory! You defeated all enemy Kryptomon!');
      } else {
        alert('üèÜ Victory! You defeated all enemy Kryptomon!');
      }
    } else {
      hapticFeedback('error');
      if (tg?.showAlert) {
        tg.showAlert('üíÄ Defeat! Your team has fallen!');
      } else {
        alert('üíÄ Defeat! Your team has fallen!');
      }
    }
    
    setTimeout(() => {
      showScreen('start-screen');
    }, 3000);
  });

  gameState.socket.on('opponentDisconnected', (data) => {
    console.log('üíî Opponent disconnected:', data);
    hapticFeedback('warning');
    
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '‚è≥ Opponent disconnected, waiting...';
    }
    
    if (data.waitingForReconnect) {
      setTimeout(() => {
        if (tg?.showAlert) {
          tg.showAlert('Opponent left the game. Returning to main menu.');
        } else {
          alert('Opponent left the game. Returning to main menu.');
        }
        showScreen('start-screen');
        gameState.inGame = false;
        gameState.gameData = null;
      }, 30000);
    }
  });

  gameState.socket.on('error', (error) => {
    console.error('üö® Socket error:', error);
    hapticFeedback('error');
    
    const status = document.getElementById('status');
    if (status && gameState.inGame) {
      if (error.message.includes('team switch')) {
        status.textContent = '‚ùå ' + error.message;
      } else if (error.message.includes('turn')) {
        status.textContent = '‚ùå Not your turn!';
      } else if (error.message.includes('mana')) {
        status.textContent = '‚ùå Not enough mana!';
      } else if (error.message.includes('cooldown')) {
        status.textContent = '‚ùå Skill on cooldown!';
      } else {
        status.textContent = '‚ùå ' + (error.message || 'Action failed');
      }
      
      setTimeout(() => {
        if (gameState.inGame) {
          status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
        }
      }, 3000);
    }
  });

  // Network quality monitoring
  setInterval(() => {
    if (gameState.connected && gameState.socket) {
      const startTime = Date.now();
      gameState.socket.emit('ping', startTime);
      
      gameState.socket.once('pong', (timestamp) => {
        const latency = Date.now() - timestamp;
        console.log(`üèì Latency: ${latency}ms`);
        
        if (latency > 1000) {
          const status = document.getElementById('status');
          if (status && gameState.inGame) {
            status.textContent = `‚ö†Ô∏è High latency: ${latency}ms`;
            setTimeout(() => {
              status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
            }, 2000);
          }
        }
      });
    }
  }, 30000);
}

// UI state management
function enableGameUI() {
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(btn => {
    btn.disabled = false;
    btn.style.opacity = '1';
    btn.style.pointerEvents = 'auto';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'auto';
    slot.style.opacity = '1';
  });
}

function disableGameUI() {
  const buttons = document.querySelectorAll('.control-btn');
  buttons.forEach(btn => {
    btn.disabled = true;
    btn.style.opacity = '0.5';
    btn.style.pointerEvents = 'none';
  });
  
  const teamSlots = document.querySelectorAll('.team-slot');
  teamSlots.forEach(slot => {
    slot.style.pointerEvents = 'none';
    slot.style.opacity = '0.5';
  });
}

// Enhanced UI update function
function updateUI(gameRoom) {
  console.log('üé® Updating UI with game data:', gameRoom);
  
  if (!gameRoom || gameState.yourIndex === null) return;
  
  try {
    // Update status
    const status = document.getElementById('status');
    if (status) {
      status.textContent = gameState.yourTurn ? 'Your Turn' : 'Enemy Turn';
    }
    
    // Update player stats
    updatePlayerStats(gameRoom);
    
    // Update team displays
    updateTeamDisplay();
    
    // Update control buttons
    updateButtons();
    
    // Update Kryptomon displays
    updateKryptomonDisplay(gameRoom);
    
  } catch (error) {
    console.error('‚ùå UI update error:', error);
  }
}

// Update player stats
function updatePlayerStats(gameRoom) {
  if (!gameRoom || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameRoom.players[gameState.yourIndex];
    const enemyData = gameRoom.players[1 - gameState.yourIndex];
    
    if (!yourData || !enemyData) return;
    
    const yourKryptomon = yourData.team[yourData.currentKryptomon];
    const enemyKryptomon = enemyData.team[enemyData.currentKryptomon];
    
    // Update your stats
    const yourHpBar = document.querySelector('.your-stats .hp-fill');
    const yourMpBar = document.querySelector('.your-stats .mp-fill');
    const yourHpText = document.querySelector('.your-stats .hp-text');
    const yourMpText = document.querySelector('.your-stats .mp-text');
    
    if (yourHpBar && yourKryptomon) {
      const hpPercent = (yourKryptomon.hp / yourKryptomon.maxHp) * 100;
      yourHpBar.style.width = hpPercent + '%';
    }
    
    if (yourMpBar && yourKryptomon) {
      const mpPercent = (yourKryptomon.mana / yourKryptomon.maxMana) * 100;
      yourMpBar.style.width = mpPercent + '%';
    }
    
    if (yourHpText && yourKryptomon) {
      yourHpText.textContent = `${yourKryptomon.hp}/${yourKryptomon.maxHp}`;
    }
    
    if (yourMpText && yourKryptomon) {
      yourMpText.textContent = `${yourKryptomon.mana}/${yourKryptomon.maxMana}`;
    }
    
    // Update enemy stats
    const enemyHpBar = document.querySelector('.enemy-stats .hp-fill');
    const enemyMpBar = document.querySelector('.enemy-stats .mp-fill');
    const enemyHpText = document.querySelector('.enemy-stats .hp-text');
    const enemyMpText = document.querySelector('.enemy-stats .mp-text');
    
    if (enemyHpBar && enemyKryptomon) {
      const hpPercent = (enemyKryptomon.hp / enemyKryptomon.maxHp) * 100;
      enemyHpBar.style.width = hpPercent + '%';
    }
    
    if (enemyMpBar && enemyKryptomon) {
      const mpPercent = (enemyKryptomon.mana / enemyKryptomon.maxMana) * 100;
      enemyMpBar.style.width = mpPercent + '%';
    }
    
    if (enemyHpText && enemyKryptomon) {
      enemyHpText.textContent = `${enemyKryptomon.hp}/${enemyKryptomon.maxHp}`;
    }
    
    if (enemyMpText && enemyKryptomon) {
      enemyMpText.textContent = `${enemyKryptomon.mana}/${enemyKryptomon.maxMana}`;
    }
    
    // Update turn indicator
    const yourPanel = document.querySelector('.your-stats');
    const enemyPanel = document.querySelector('.enemy-stats');
    
    if (yourPanel && enemyPanel) {
      yourPanel.classList.toggle('your-turn', gameState.yourTurn);
      enemyPanel.classList.toggle('your-turn', !gameState.yourTurn);
    }
    
  } catch (error) {
    console.error('‚ùå Player stats update error:', error);
  }
}

// Update team display
function updateTeamDisplay() {
  if (!gameState.gameData || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameState.gameData.players[gameState.yourIndex];
    const enemyData = gameState.gameData.players[1 - gameState.yourIndex];
    
    // Update your team slots
    const yourSlots = document.querySelectorAll('.your-team .team-slot');
    yourSlots.forEach((slot, index) => {
      if (yourData.team[index]) {
        slot.classList.remove('active', 'dead');
        
        if (yourData.team[index].isAlive) {
          if (index === yourData.currentKryptomon) {
            slot.classList.add('active');
          }
        } else {
          slot.classList.add('dead');
        }
        
        // Update sprite
        const img = slot.querySelector('img');
        if (img) {
          img.src = `kryptomon${yourData.team[index].sprite}.png`;
        }
      }
    });
    
    // Update enemy team slots
    const enemySlots = document.querySelectorAll('.enemy-team .team-slot');
    enemySlots.forEach((slot, index) => {
      if (enemyData.team[index]) {
        slot.classList.remove('active', 'dead');
        
        if (enemyData.team[index].isAlive) {
          if (index === enemyData.currentKryptomon) {
            slot.classList.add('active');
          }
        } else {
          slot.classList.add('dead');
        }
        
        // Update sprite
        const img = slot.querySelector('img');
        if (img) {
          img.src = `kryptomon${enemyData.team[index].sprite}.png`;
        }
      }
    });
    
  } catch (error) {
    console.error('‚ùå Team display update error:', error);
  }
}

// Update control buttons
function updateButtons() {
  if (!gameState.gameData || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameState.gameData.players[gameState.yourIndex];
    const currentKryptomon = yourData.team[yourData.currentKryptomon];
    
    if (!currentKryptomon) return;
    
    // Update button states
    const attackBtn = document.getElementById('attack-btn');
    const defendBtn = document.getElementById('defend-btn');
    const skillBtn = document.getElementById('skill-btn');
    const ultimateBtn = document.getElementById('ultimate-btn');
    
    // Attack - always available if alive
    if (attackBtn) {
      attackBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive;
    }
    
    // Defend - check cooldown
    if (defendBtn) {
      defendBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || yourData.defendCooldown > 0;
      if (yourData.defendCooldown > 0) {
        defendBtn.textContent = `Defend (${yourData.defendCooldown})`;
      } else {
        defendBtn.textContent = 'Defend';
      }
    }
    
    // Skill - check mana
    if (skillBtn) {
      skillBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || currentKryptomon.mana < 2;
      skillBtn.textContent = `Skill (2 MP)`;
    }
    
    // Ultimate - check mana and usage
    if (ultimateBtn) {
      ultimateBtn.disabled = !gameState.yourTurn || !currentKryptomon.isAlive || 
                            currentKryptomon.mana < 6 || currentKryptomon.ultimateUsed;
      if (currentKryptomon.ultimateUsed) {
        ultimateBtn.textContent = 'Ultimate (Used)';
      } else {
        ultimateBtn.textContent = `Ultimate (6 MP)`;
      }
    }
    
  } catch (error) {
    console.error('‚ùå Button update error:', error);
  }
}

// Update Kryptomon display
function updateKryptomonDisplay(gameRoom) {
  if (!gameRoom || gameState.yourIndex === null) return;
  
  try {
    const yourData = gameRoom.players[gameState.yourIndex];
    const enemyData = gameRoom.players[1 - gameState.yourIndex];
    
    // Update your Kryptomon
    const yourKryptomon = document.querySelector('.kryptomon.yours img');
    if (yourKryptomon && yourData.team[yourData.currentKryptomon]) {
      yourKryptomon.src = `kryptomon${yourData.team[yourData.currentKryptomon].sprite}.png`;
    }
    
    // Update enemy Kryptomon
    const enemyKryptomon = document.querySelector('.kryptomon.enemy img');
    if (enemyKryptomon && enemyData.team[enemyData.currentKryptomon]) {
      enemyKryptomon.src = `kryptomon${enemyData.team[enemyData.currentKryptomon].sprite}.png`;
    }
    
  } catch (error) {
    console.error('‚ùå Kryptomon display update error:', error);
  }
}

// Process move result with animations
function processMoveResult(moveResult) {
  try {
    console.log('‚ö° Processing move result:', moveResult);
    
    // Play sound effect
    if (moveResult.soundEffect) {
      playSound(moveResult.soundEffect);
    }
    
    // Show damage text
    if (moveResult.damageInfo) {
      showDamageText(moveResult.damageInfo);
    }
    
    // Apply visual effects
    applyMoveAnimation(moveResult);
    
    // Handle special effects
    if (moveResult.effects && moveResult.effects.length > 0) {
      moveResult.effects.forEach(effect => {
        handleSpecialEffect(effect);
      });
    }
    
  } catch (error) {
    console.error('‚ùå Move result processing error:', error);
  }
}

// Apply move animations
function applyMoveAnimation(moveResult) {
  try {
    const isYourMove = moveResult.playerIndex === gameState.yourIndex;
    const kryptomonElement = document.querySelector(isYourMove ? '.kryptomon.yours' : '.kryptomon.enemy');
    
    if (kryptomonElement) {
      // Remove existing animation classes
      kryptomonElement.classList.remove('attacking', 'defending', 'skill', 'ultimate');
      
      // Add new animation class
      switch(moveResult.moveType) {
        case 'attack':
          kryptomonElement.classList.add('attacking');
          break;
        case 'defend':
          kryptomonElement.classList.add('defending');
          break;
        case 'skill':
          kryptomonElement.classList.add('skill');
          break;
        case 'ultimate':
          kryptomonElement.classList.add('ultimate');
          break;
      }
      
      // Remove animation class after animation completes
      setTimeout(() => {
        kryptomonElement.classList.remove('attacking', 'defending', 'skill', 'ultimate');
      }, 3000);
    }
    
  } catch (error) {
    console.error('‚ùå Animation error:', error);
  }
}

// Show damage text
function showDamageText(damageInfo) {
  try {
    const isTargetEnemy = damageInfo.target === 'enemy';
    const targetElement = document.querySelector(isTargetEnemy ? '.kryptomon.enemy' : '.kryptomon.yours');
    
    if (targetElement) {
      const damageText = document.createElement('div');
      damageText.className = 'damage-text';
      
      if (damageInfo.damage > 0) {
        if (damageInfo.target === 'self') {
          damageText.textContent = `+${damageInfo.damage}`;
          damageText.classList.add('heal');
        } else {
          damageText.textContent = `-${damageInfo.damage}`;
          if (damageInfo.isCritical) {
            damageText.classList.add('critical');
            damageText.textContent += ' CRIT!';
          } else {
            damageText.classList.add('damage');
          }
        }
      }
      
      // Position the damage text
      const rect = targetElement.getBoundingClientRect();
      damageText.style.left = (rect.left + rect.width / 2) + 'px';
      damageText.style.top = (rect.top + rect.height / 2) + 'px';
      damageText.style.position = 'fixed';
      damageText.style.zIndex = '1000';
      
      document.body.appendChild(damageText);
      
      // Remove after animation
      setTimeout(() => {
        if (damageText.parentNode) {
          damageText.parentNode.removeChild(damageText);
        }
      }, 2500);
    }
    
  } catch (error) {
    console.error('‚ùå Damage text error:', error);
  }
}

// Handle special effects
function handleSpecialEffect(effect) {
  switch(effect) {
    case 'kryptomon_defeated':
      hapticFeedback('heavy');
      console.log('üíÄ Kryptomon defeated!');
      break;
    case 'kryptomon_switch':
      hapticFeedback('light');
      console.log('üîÑ Kryptomon switched!');
      break;
    case 'game_over':
      hapticFeedback('success');
      console.log('üèÅ Game over!');
      break;
  }
}

// Placeholder functions
function playSound(soundName) {
  console.log('üîä Playing sound:', soundName);
  // TODO: Implement actual sound playing
}

function showMessage(message, type) {
  console.log('üí¨ Message:', message, type);
  // TODO: Implement message display
}

// Team switching function
function switchKryptomon(index) {
  console.log('üîÑ Switching to Kryptomon:', index);
  
  if (!gameState.socket || !gameState.inGame) {
    console.log('‚ùå Cannot switch: not in game');
    hapticFeedback('error');
    return;
  }

  if (!gameState.connected) {
    console.log('‚ùå Cannot switch: not connected');
    hapticFeedback('error');
    return;
  }

  if (!gameState.yourTurn) {
    console.log('‚ùå Cannot switch: not your turn');
    hapticFeedback('error');
    return;
  }

  // Validate switch locally
  if (!gameState.gameData || gameState.yourIndex === null) {
    console.log('‚ùå Cannot switch: no game data');
    hapticFeedback('error');
    return;
  }

  const yourData = gameState.gameData.players[gameState.yourIndex];
  if (!yourData || !yourData.team[index]) {
    console.log('‚ùå Cannot switch: invalid kryptomon index');
    hapticFeedback('error');
    return;
  }

  if (!yourData.team[index].isAlive) {
    console.log('‚ùå Cannot switch: kryptomon is defeated');
    hapticFeedback('error');
    return;
  }

  if (index === yourData.currentKryptomon) {
    console.log('‚ùå Cannot switch: already using this kryptomon');
    hapticFeedback('light');
    return;
  }

  try {
    gameState.socket.emit('requestTeamSwitch', {
      kryptomonIndex: index
    });
    
    hapticFeedback('light');
    
  } catch (error) {
    console.error('‚ùå Switch request failed:', error);
    hapticFeedback('error');
  }
}

// Battle move function
function performBattleMove(moveType) {
  console.log('‚öîÔ∏è Performing move:', moveType);
  
  if (!gameState.connected || !gameState.socket) {
    hapticFeedback('error');
    return;
  }

  if (!gameState.inGame) {
    hapticFeedback('error');
    return;
  }

  if (!gameState.yourTurn) {
    hapticFeedback('error');
    return;
  }

  try {
    // Disable buttons temporarily
    const buttons = document.querySelectorAll('.control-btn');
    buttons.forEach(btn => btn.disabled = true);
    
    gameState.socket.emit('battleMove', {
      move: moveType
    });
    
    hapticFeedback('medium');
    
    // Re-enable buttons after delay
    setTimeout(() => {
      buttons.forEach(btn => btn.disabled = false);
      updateButtons(); // Apply proper button states
    }, 1000);
    
  } catch (error) {
    console.error('‚ùå Battle move failed:', error);
    hapticFeedback('error');
    
    // Re-enable buttons on error
    const buttons = document.querySelectorAll('.control-btn');
    buttons.forEach(btn => btn.disabled = false);
  }
}

// Start game function
function startGame() {
  const nameInput = document.getElementById('playerName');
  if (nameInput && nameInput.value.trim()) {
    gameState.playerName = nameInput.value.trim();
  }
  
  console.log('üéÆ Starting game as:', gameState.playerName);
  hapticFeedback('light');
  connectToServer();
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
  console.log('üöÄ Page loaded, initializing...');
  showScreen('start-screen');
  
  // Auto-fill Telegram name if available
  if (gameState.playerName !== 'Anonymous') {
    const nameInput = document.getElementById('playerName');
    if (nameInput) {
      nameInput.value = gameState.playerName;
    }
  }
  
  // Auto-start for Telegram users
  if (isTelegramWebApp) {
    setTimeout(() => {
      startGame();
    }, 1000);
  }
});
</script>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    height: 100vh;
    overflow: hidden;
    position: fixed;
    width: 100%;
    -webkit-font-smoothing: antialiased;
  }

  /* Connection Status */
  .connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    z-index: 1000;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }

  .connection-status.connecting {
    background: rgba(52, 152, 219, 0.9);
    animation: pulse 1.5s infinite;
  }

  .connection-status.connected {
    background: rgba(46, 204, 113, 0.9);
  }

  .connection-status.disconnected {
    background: rgba(231, 76, 60, 0.9);
    animation: shake 0.5s ease-in-out;
  }

  .connection-status.reconnecting {
    background: rgba(241, 196, 15, 0.9);
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.05); }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }

  .screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    padding: 20px;
    transition: opacity 0.3s ease;
  }

  .hidden {
    display: none !important;
  }

  /* Start Screen */
  #start-screen {
    background: rgba(0,0,0,0.95);
    text-align: center;
  }

  #start-screen h1 {
    font-size: clamp(2rem, 5vw, 3rem);
    margin-bottom: 20px;
    color: #FFD700;
    text-shadow: 0 0 20px rgba(255,215,0,0.5);
    animation: glow 2s ease-in-out infinite alternate;
  }

  @keyframes glow {
    from { text-shadow: 0 0 20px rgba(255,215,0,0.5); }
    to { text-shadow: 0 0 30px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.3); }
  }

  #start-screen input {
    padding: 15px;
    font-size: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 25px;
    margin: 10px 0;
    width: 90%;
    max-width: 300px;
    text-align: center;
    background: rgba(255,255,255,0.1);
    color: white;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }

  #start-screen input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
  }

  #start-screen input::placeholder {
    color: rgba(255,255,255,0.7);
  }

  #start-screen button {
    padding: 15px 30px;
    font-size: 16px;
    font-weight: bold;
    border: none;
    border-radius: 25px;
    margin: 10px;
    cursor: pointer;
    width: 90%;
    max-width: 300px;
    transition: all 0.3s ease;
    background: linear-gradient(135deg, #2ecc71, #27ae60);
    color: white;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255,255,255,0.2);
  }

  #start-screen button:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 25px rgba(46, 204, 113, 0.3);
  }

  /* Waiting Screen */
  #waiting-screen {
    background: rgba(0,0,0,0.95);
    text-align: center;
  }

  #waiting-screen h2 {
    font-size: 1.8em;
    margin-bottom: 15px;
    color: #FFD700;
  }

  .spinner {
    border: 3px solid #f3f3f3;
    border-top: 3px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 2s linear infinite;
    margin: 15px auto;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  #waiting-message {
    font-size: 16px;
    margin-top: 15px;
    color: rgba(255,255,255,0.9);
  }

  /* Game Screen */
  #game-screen {
    background: url('background.png') center/cover,
                linear-gradient(135deg, #8B4513, #D2691E);
    position: relative;
    overflow: hidden;
  }

  /* Game Header */
  .game-header {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.9);
    padding: 10px 20px;
    border-radius: 15px;
    text-align: center;
    z-index: 100;
    backdrop-filter: blur(15px);
    border: 2px solid #FFD700;
    min-width: 200px;
  }

  #status {
    font-size: 14px;
    font-weight: bold;
    color: #FFD700;
  }

  /* Player Stats */
  .player-stats {
    position: absolute;
    top: 80px;
    left: 15px;
    right: 15px;
    display: flex;
    justify-content: space-between;
    gap: 15px;
    z-index: 100;
  }

  .stat-panel {
    background: rgba(0,0,0,0.9);
    padding: 12px 15px;
    border-radius: 15px;
    flex: 1;
    max-width: 45%;
    backdrop-filter: blur(15px);
    border: 2px solid rgba(255,255,255,0.2);
    transition: all 0.3s ease;
  }

  .stat-panel.your-turn {
    border-color: #2ecc71;
    box-shadow: 0 0 20px rgba(46, 204, 113, 0.3);
  }

  .stat-panel h3 {
    font-size: 13px;
    margin-bottom: 8px;
    color: #FFD700;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .stat-bar {
    background: rgba(255,255,255,0.2);
    height: 14px;
    border-radius: 7px;
    overflow: hidden;
    margin: 5px 0;
    position: relative;
  }

  .stat-fill {
    height: 100%;
    transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 7px;
  }

  .hp-fill {
    background: linear-gradient(90deg, #e74c3c, #27ae60);
  }

  .mp-fill {
    background: linear-gradient(90deg, #3498db, #9b59b6);
  }

  .stat-text {
    font-size: 11px;
    color: rgba(255,255,255,0.9);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
  }

  /* Battle Arena */
  .battle-arena {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 90%;
    max-width: 400px;
    height: 220px;
    gap: 60px;
  }

  .kryptomon {
    width: 130px;
    height: 130px;
    border-radius: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
    overflow: hidden;
    cursor: pointer;
    border: 3px solid rgba(255,255,255,0.3);
    backdrop-filter: blur(5px);
  }

  .kryptomon img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 17px;
    transition: all 0.3s ease;
  }

  .kryptomon.enemy img {
    transform: scaleX(-1);
  }

  /* Team Display */
  .team-display {
    position: absolute;
    bottom: 90px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    z-index: 90;
  }

  .team-slot {
    width: 50px;
    height: 50px;
    border-radius: 10px;
    border: 2px solid rgba(255,255,255,0.3);
    background-size: cover;
    background-position: center;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .team-slot img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 8px;
  }

  .team-slot.active {
    border-color: #2ecc71;
    box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
    transform: scale(1.1);
  }

  .team-slot.dead {
    opacity: 0.3;
    filter: grayscale(100%);
    cursor: not-allowed;
  }

  .team-slot:not(.dead):not(.active):hover {
    border-color: #3498db;
    transform: scale(1.05);
  }

  /* Controls */
  .controls {
    position: absolute;
    bottom: 15px;
    left: 50%;
    transform: translateX(-50%);
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    width: 95%;
    max-width: 350px;
  }

  .control-btn {
    padding: 12px 8px;
    font-size: 12px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    color: white;
    min-height: 55px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 3px;
    border: 2px solid rgba(255,255,255,0.3);
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
  }

  .control-btn:disabled {
    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    cursor: not-allowed;
    opacity: 0.6;
  }

  .control-btn:not(:disabled):active {
    transform: scale(0.95);
  }

  .btn-attack {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
  }

  .btn-defend {
    background: linear-gradient(135deg, #3498db, #2980b9);
  }

  .btn-skill {
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
  }

  .btn-ultimate {
    background: linear-gradient(135deg, #f39c12, #e67e22);
  }

  /* Damage Text */
  .damage-text {
    position: absolute;
    font-size: 24px;
    font-weight: bold;
    pointer-events: none;
    z-index: 200;
    animation: damageFloat 2.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  }

  .damage-text.damage {
    color: #e74c3c;
  }

  .damage-text.critical {
    color: #FFD700;
    font-size: 32px;
    text-shadow: 0 0 15px #FFD700;
  }

  .damage-text.heal {
    color: #2ecc71;
  }

  @keyframes damageFloat {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    20% { opacity: 1; transform: translateY(-20px) scale(1.2); }
    100% { opacity: 0; transform: translateY(-80px) scale(0.8); }
  }

  /* Battle Animations */
  .kryptomon.attacking {
    animation: attackBite 1.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .kryptomon.defending {
    animation: defendShield 1.8s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .kryptomon.skill {
    animation: skillGlow 2.2s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .kryptomon.ultimate {
    animation: ultimateBlast 3.5s cubic-bezier(0.4, 0, 0.2, 1);
  }

  @keyframes attackBite {
    0% { transform: translateX(0) scale(1) rotate(0deg); }
    15% { transform: translateX(20px) scale(1.15) rotate(8deg); }
    30% { transform: translateX(35px) scale(1.25) rotate(-5deg); }
    45% { transform: translateX(40px) scale(1.3) rotate(3deg); }
    60% { transform: translateX(25px) scale(1.2) rotate(-2deg); }
    80% { transform: translateX(10px) scale(1.1) rotate(1deg); }
    100% { transform: translateX(0) scale(1) rotate(0deg); }
  }

  @keyframes defendShield {
    0% { transform: scale(1); filter: drop-shadow(0 0 0px #3498db) brightness(1); }
    20% { transform: scale(0.9); filter: drop-shadow(0 0 20px #3498db) brightness(1.4); }
    40% { transform: scale(1.15); filter: drop-shadow(0 0 30px #3498db) brightness(1.6); }
    60% { transform: scale(1.05); filter: drop-shadow(0 0 25px #3498db) brightness(1.5); }
    80% { transform: scale(0.95); filter: drop-shadow(0 0 15px #3498db) brightness(1.3); }
    100% { transform: scale(1); filter: drop-shadow(0 0 0px #3498db) brightness(1); }
  }

  @keyframes skillGlow {
    0% { transform: scale(1) rotate(0deg); filter: brightness(1) hue-rotate(0deg); }
    20% { transform: scale(1.1) rotate(5deg); filter: brightness(1.4) hue-rotate(60deg); }
    40% { transform: scale(1.2) rotate(-5deg); filter: brightness(1.6) hue-rotate(120deg); }
    60% { transform: scale(1.15) rotate(3deg); filter: brightness(1.5) hue-rotate(180deg); }
    80% { transform: scale(1.05) rotate(-2deg); filter: brightness(1.3) hue-rotate(240deg); }
    100% { transform: scale(1) rotate(0deg); filter: brightness(1) hue-rotate(360deg); }
  }

  @keyframes ultimateBlast {
    0% { transform: scale(1) rotate(0deg); filter: brightness(1) saturate(1) hue-rotate(0deg); }
    10% { transform: scale(1.2) rotate(15deg); filter: brightness(2) saturate(2) hue-rotate(60deg); }
    20% { transform: scale(1.4) rotate(-20deg); filter: brightness(2.5) saturate(2.5) hue-rotate(120deg); }
    30% { transform: scale(1.6) rotate(25deg); filter: brightness(3) saturate(3) hue-rotate(180deg); }
    50% { transform: scale(1.8) rotate(-30deg); filter: brightness(3.5) saturate(3.5) hue-rotate(240deg); }
    70% { transform: scale(1.5) rotate(20deg); filter: brightness(2.8) saturate(2.8) hue-rotate(300deg); }
    85% { transform: scale(1.2) rotate(-10deg); filter: brightness(2) saturate(2) hue-rotate(330deg); }
    100% { transform: scale(1) rotate(0deg); filter: brightness(1) saturate(1) hue-rotate(360deg); }
  }
</style>
</head>

<body>
  <!-- Connection Status -->
  <div id="connection-status" class="connection-status" style="display: none;"></div>

  <!-- Start Screen -->
  <div id="start-screen" class="screen">
    <h1>üêæ Kryptomon Battle Arena</h1>
    <input type="text" id="playerName" placeholder="Enter your name" />
    <button onclick="startGame()">‚öîÔ∏è Start Battle</button>
  </div>

  <!-- Waiting Screen -->
  <div id="waiting-screen" class="screen hidden">
    <h2>üîç Finding Opponent</h2>
    <div class="spinner"></div>
    <div id="waiting-message">Searching for worthy opponent...</div>
  </div>

  <!-- Game Screen -->
  <div id="game-screen" class="screen hidden">
    <!-- Game Header -->
    <div class="game-header">
      <div id="status">Waiting...</div>
    </div>

    <!-- Player Stats -->
    <div class="player-stats">
      <div class="stat-panel your-stats">
        <h3>You</h3>
        <div class="stat-bar">
          <div class="stat-fill hp-fill" style="width: 100%;"></div>
          <div class="stat-text hp-text">100/100</div>
        </div>
        <div class="stat-bar">
          <div class="stat-fill mp-fill" style="width: 0%;"></div>
          <div class="stat-text mp-text">0/100</div>
        </div>
      </div>
      
      <div class="stat-panel enemy-stats">
        <h3>Enemy</h3>
        <div class="stat-bar">
          <div class="stat-fill hp-fill" style="width: 100%;"></div>
          <div class="stat-text hp-text">100/100</div>
        </div>
        <div class="stat-bar">
          <div class="stat-fill mp-fill" style="width: 0%;"></div>
          <div class="stat-text mp-text">0/100</div>
        </div>
      </div>
    </div>

    <!-- Battle Arena -->
    <div class="battle-arena">
      <div class="kryptomon yours">
        <img src="kryptomon1.png" alt="Your Kryptomon" />
      </div>
      <div class="kryptomon enemy">
        <img src="kryptomon2.png" alt="Enemy Kryptomon" />
      </div>
    </div>

    <!-- Team Display -->
    <div class="team-display your-team">
      <div class="team-slot" data-index="0" onclick="switchKryptomon(0)">
        <img src="kryptomon1.png" alt="Kryptomon 1" />
      </div>
      <div class="team-slot" data-index="1" onclick="switchKryptomon(1)">
        <img src="kryptomon2.png" alt="Kryptomon 2" />
      </div>
      <div class="team-slot" data-index="2" onclick="switchKryptomon(2)">
        <img src="kryptomon3.png" alt="Kryptomon 3" />
      </div>
    </div>

    <!-- Controls -->
    <div class="controls">
      <button id="attack-btn" class="control-btn btn-attack" onclick="performBattleMove('attack')">
        Attack
      </button>
      <button id="defend-btn" class="control-btn btn-defend" onclick="performBattleMove('defend')">
        Defend
      </button>
      <button id="skill-btn" class="control-btn btn-skill" onclick="performBattleMove('skill')">
        Skill (2 MP)
      </button>
      <button id="ultimate-btn" class="control-btn btn-ultimate" onclick="performBattleMove('ultimate')">
        Ultimate (6 MP)
      </button>
    </div>
  </div>
</body>
</html>
