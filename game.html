<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NFT PvP Turn-Based Game + Chat</title>
<style>
  /* CSS kodlarƒ± aynƒ± kalƒ±yor - √∂nceki stillemeler */
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #fff;
    text-align: center;
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
  }
  
  #container {
    display: flex;
    width: 1200px;
    max-width: 95vw;
    height: 90vh;
    background: rgba(30, 30, 30, 0.95);
    border-radius: 20px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
    overflow: hidden;
  }
  
  #game {
    flex: 2.5;
    padding: 30px;
    position: relative;
    background: rgba(40, 40, 40, 0.8);
  }
  
  /* MetaMask Connection Styles */
  #metamask-container, #nft-selection-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    backdrop-filter: blur(10px);
  }
  
  #metamask-modal, #nft-selection-modal {
    background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    max-width: 700px;
    width: 90%;
    max-height: 85vh;
    overflow-y: auto;
    box-shadow: 0 25px 50px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  #connect-wallet-btn {
    background: linear-gradient(45deg, #f6851b, #ff6b35);
    color: white;
    border: none;
    padding: 15px 30px;
    border-radius: 10px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    margin-top: 20px;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(246, 133, 27, 0.3);
  }
  
  #connect-wallet-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(246, 133, 27, 0.4);
  }
  
  #connect-wallet-btn:disabled {
    background: #666;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }
  
  /* NFT Selection Styles */
  #nft-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 20px;
    margin-top: 25px;
    padding: 20px 0;
  }
  
  .nft-card {
    background: rgba(60, 60, 60, 0.9);
    border-radius: 15px;
    padding: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  
  .nft-card:hover {
    transform: translateY(-5px);
    border-color: #3498db;
    box-shadow: 0 10px 30px rgba(52, 152, 219, 0.3);
  }
  
  .nft-card.selected {
    border-color: #2ecc71;
    background: rgba(46, 204, 113, 0.2);
    transform: translateY(-5px);
    box-shadow: 0 10px 30px rgba(46, 204, 113, 0.4);
  }
  
  .nft-image {
    width: 100%;
    height: 140px;
    object-fit: cover;
    border-radius: 10px;
    margin-bottom: 15px;
    background: linear-gradient(45deg, #667eea, #764ba2);
    border: 2px solid rgba(255,255,255,0.1);
  }
  
  /* Diƒüer CSS'ler aynƒ±... */
  
  .loading {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 30px 0;
    font-size: 16px;
  }
  
  .spinner {
    border: 3px solid rgba(255,255,255,0.3);
    border-top: 3px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin-right: 15px;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Oyun alanƒ± ve diƒüer CSS'ler aynƒ± kalƒ±yor... */
</style>
</head>
<body>

<!-- MetaMask Connection Modal -->
<div id="metamask-container">
  <div id="metamask-modal">
    <h2>ü¶ä Connect Your Wallet</h2>
    <p>You need to connect your MetaMask wallet to play this NFT game.</p>
    <div id="metamask-status">
      <p id="connection-status">Please install MetaMask or connect your wallet.</p>
    </div>
    <button id="connect-wallet-btn">Connect MetaMask</button>
  </div>
</div>

<!-- NFT Selection Modal -->
<div id="nft-selection-container" style="display: none;">
  <div id="nft-selection-modal">
    <h2>‚öîÔ∏è Select Your NFT Character</h2>
    <p>Choose an NFT from your collection to use as your warrior:</p>
    <div id="nft-loading" class="loading" style="display: none;">
      <div class="spinner"></div>
      <span>Loading your NFTs...</span>
    </div>
    <div id="nft-error" style="display: none; color: #e74c3c; margin: 20px 0; padding: 15px; background: rgba(231, 76, 60, 0.1); border-radius: 8px;"></div>
    <div id="nft-grid"></div>
    <div style="margin-top: 25px;">
      <button id="select-nft-btn" disabled>‚ö° Enter Battle</button>
      <button id="refresh-nfts-btn">üîÑ Refresh NFTs</button>
    </div>
  </div>
</div>

<!-- Wallet Status Display -->
<div class="wallet-status" id="wallet-status" style="display: none;">
  üîó <span id="connected-address"></span>
</div>

<div id="container" style="display: none;">
  <div id="game">
    <div class="player-area">
      <div class="player" id="you">
        <div class="player-nft-info your-nft-info" id="your-nft-info">Your NFT</div>
        <div class="player-stats" id="your-stats">
          <span class="stat health-stat">‚ù§Ô∏è <span id="your-base-health">100</span></span>
          <span class="stat attack-stat">‚öîÔ∏è <span id="your-attack">10</span></span>
          <span class="stat defense-stat">üõ°Ô∏è <span id="your-defense">5</span></span>
        </div>
        <img src="" alt="Your NFT" class="character" id="player-avatar" />
        <div class="bar" title="Health">
          <div class="bar-fill health-fill" id="you-health" style="width: 100%;"></div>
          <div class="bar-label" id="you-health-label">Health: 0</div>
        </div>
        <div class="bar" title="Mana">
          <div class="bar-fill mana-fill" id="you-mana" style="width: 100%;"></div>
          <div class="bar-label" id="you-mana-label">Mana: 0</div>
        </div>
      </div>

      <div class="player" id="enemy">
        <div class="player-nft-info enemy-nft-info" id="enemy-nft-info">Enemy NFT</div>
        <div class="player-stats" id="enemy-stats">
          <span class="stat health-stat">‚ù§Ô∏è <span id="enemy-base-health">100</span></span>
          <span class="stat attack-stat">‚öîÔ∏è <span id="enemy-attack">10</span></span>
          <span class="stat defense-stat">üõ°Ô∏è <span id="enemy-defense">5</span></span>
        </div>
        <img src="" alt="Enemy NFT" class="character" id="enemy-avatar" />
        <div class="bar" title="Health">
          <div class="bar-fill health-fill" id="enemy-health" style="width: 100%;"></div>
          <div class="bar-label" id="enemy-health-label">Health: 0</div>
        </div>
        <div class="bar" title="Mana">
          <div class="bar-fill mana-fill" id="enemy-mana" style="width: 100%;"></div>
          <div class="bar-label" id="enemy-mana-label">Mana: 0</div>
        </div>
      </div>
    </div>

    <div id="actions">
      <button class="action-btn" id="attack-btn" title="Attack - Cost: 10 Mana">
        <div>‚öîÔ∏è</div>
        <div style="font-size: 11px;">Attack</div>
      </button>
      <button class="action-btn" id="defend-btn" title="Defend - Cost: 5 Mana">
        <div>üõ°Ô∏è</div>
        <div style="font-size: 11px;">Defend</div>
      </button>
      <button class="action-btn" id="skill-btn" title="Special Skill - Cost: 20 Mana">
        <div>‚ú®</div>
        <div style="font-size: 11px;">Skill</div>
      </button>
      <button class="action-btn" id="mana-btn" title="Restore Mana">
        <div>üí´</div>
        <div style="font-size: 11px;">Mana</div>
      </button>
      <button class="action-btn" id="hydra-btn" title="Ultimate Attack - Cost: 30 Mana">
        <div>üê≤</div>
        <div style="font-size: 11px;">Ultimate</div>
      </button>
    </div>

    <div id="status">Ready to battle!</div>

    <div id="victory-message">üéâ Victory!</div>
    <button id="back-to-menu-btn">üè† Back To Menu</button>
    <button id="play-again-btn">üîÑ Play Again</button>
  </div>

  <!-- CHAT -->
  <div id="chat-container">
    <div id="chat-messages"></div>
    <div id="chat-input-area">
      <input type="text" id="chat-input" placeholder="Type message... (max 20 chars)" autocomplete="off" maxlength="20" />
      <span id="char-count">0/20</span>
      <button id="chat-send-btn" disabled>Send</button>
    </div>
  </div>
</div>

<!-- Socket.io ve Ethers.js y√ºkle -->
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>

<script>
  // Global deƒüi≈ükenler
  let currentAccount = null;
  let provider = null;
  let signer = null;
  let selectedNFT = null;
  let userNFTs = [];
  let socket = null;
  let yourIndex = null;
  let yourData = null;
  let enemyData = null;
  let yourTurn = false;
  let gameActive = false;
  let yourNFTStats = null;
  let enemyNFTStats = null;

  // NFT Contract Address
  const NFT_CONTRACT_ADDRESS = "0xdfdb045e4300d04ec32058756ec2453409360c5b";
  
  // Backend URL
  const BACKEND_URL = "https://pvpbackend.onrender.com";
  
  // Basit ERC721 ABI
  const ERC721_ABI = [
    "function balanceOf(address owner) view returns (uint256)",
    "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
    "function tokenURI(uint256 tokenId) view returns (string)"
  ];

  // DOM elemanlarƒ±
  const metamaskContainer = document.getElementById('metamask-container');
  const nftSelectionContainer = document.getElementById('nft-selection-container');
  const connectWalletBtn = document.getElementById('connect-wallet-btn');
  const connectionStatus = document.getElementById('connection-status');
  const walletStatus = document.getElementById('wallet-status');
  const connectedAddress = document.getElementById('connected-address');
  const gameContainer = document.getElementById('container');
  const nftGrid = document.getElementById('nft-grid');
  const selectNFTBtn = document.getElementById('select-nft-btn');
  const refreshNFTsBtn = document.getElementById('refresh-nfts-btn');
  const nftLoading = document.getElementById('nft-loading');
  const nftError = document.getElementById('nft-error');

  // Oyun elemanlarƒ±
  const youHealthBar = document.getElementById('you-health');
  const youManaBar = document.getElementById('you-mana');
  const youHealthLabel = document.getElementById('you-health-label');
  const youManaLabel = document.getElementById('you-mana-label');
  const playerAvatar = document.getElementById('player-avatar');

  const enemyHealthBar = document.getElementById('enemy-health');
  const enemyManaBar = document.getElementById('enemy-mana');
  const enemyHealthLabel = document.getElementById('enemy-health-label');
  const enemyManaLabel = document.getElementById('enemy-mana-label');
  const enemyAvatar = document.getElementById('enemy-avatar');

  const statusDiv = document.getElementById('status');
  const victoryMessage = document.getElementById('victory-message');
  const backToMenuBtn = document.getElementById('back-to-menu-btn');
  const playAgainBtn = document.getElementById('play-again-btn');

  const attackBtn = document.getElementById('attack-btn');
  const defendBtn = document.getElementById('defend-btn');
  const skillBtn = document.getElementById('skill-btn');
  const manaBtn = document.getElementById('mana-btn');
  const hydraBtn = document.getElementById('hydra-btn');

  // Chat elemanlarƒ±
  const chatMessages = document.getElementById('chat-messages');
  const chatInput = document.getElementById('chat-input');
  const chatSendBtn = document.getElementById('chat-send-btn');
  const charCount = document.getElementById('char-count');

  // NFT √∂zelliklerinden oyun statlarƒ± hesaplama
  function calculateNFTStats(nft) {
    let health = 150;
    let attack = 15;
    let defense = 5;
    let speed = 10;

    const tokenIdNum = parseInt(nft.tokenId) || 0;
    
    // Token ID bazlƒ± deterministic stat hesaplama
    const healthMod = (tokenIdNum * 7) % 50;
    const attackMod = (tokenIdNum * 11) % 25;
    const defenseMod = (tokenIdNum * 13) % 15;
    const speedMod = (tokenIdNum * 17) % 20;
    
    health += healthMod;
    attack += Math.floor(attackMod / 2);
    defense += Math.floor(defenseMod / 3);
    speed += Math.floor(speedMod / 2);

    // Rarity bonusu
    const rarityValue = tokenIdNum % 100;
    
    if (rarityValue >= 95) {
      health += 50; attack += 12; defense += 8;
      nft.rarity = "Legendary";
    } else if (rarityValue >= 80) {
      health += 30; attack += 8; defense += 5;
      nft.rarity = "Epic";
    } else if (rarityValue >= 50) {
      health += 20; attack += 5; defense += 3;
      nft.rarity = "Rare";
    } else {
      nft.rarity = "Common";
    }

    return {
      health: Math.min(health, 300),
      attack: Math.min(attack, 50),
      defense: Math.min(defense, 25),
      speed: Math.min(speed, 35)
    };
  }

  // Ger√ßek NFT resim URL'lerini olu≈üturma
  function generateNFTImageURL(tokenId) {
    // Bu kontrat i√ßin ger√ßek NFT resimleri (√∂rnekler)
    const realNFTImages = [
      `https://ipfs.io/ipfs/QmYx6GsYAKnNzZ9A6NvEKV9nf1VaDzJrqDR23Y8YSkebLU/${tokenId}`,
      `https://api.kryptomon.co/json/kryptomon/meta/${tokenId}`,
      `https://metadata.ens.domains/mainnet/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85/${tokenId}`,
      `https://arweave.net/abc123def456ghi789jkl012mno345pqr678stu901vwx234yz/${tokenId}.json`
    ];
    
    // Ger√ßek NFT koleksiyonu i√ßin IPFS/Arweave URL'si
    const baseImageURL = `https://gateway.pinata.cloud/ipfs/QmYourHashHere/${tokenId}.png`;
    
    // Fallback olarak g√ºzel NFT-style resimler
    const fallbackImages = [
      `https://api.dicebear.com/7.x/pixel-art/svg?seed=${tokenId}&backgroundColor=b6e3f4,c0aede,d1d4f9`,
      `https://api.dicebear.com/7.x/avataaars/svg?seed=${tokenId}&backgroundColor=b6e3f4,c0aede,d1d4f9`,
      `https://robohash.org/${tokenId}?set=set4&size=200x200`,
      `https://avatars.githubusercontent.com/u/${Math.abs(parseInt(tokenId) * 12345) % 100000000}?s=200`
    ];
    
    // Token ID'sine g√∂re bir resim se√ß
    const imageIndex = parseInt(tokenId) % fallbackImages.length;
    return fallbackImages[imageIndex];
  }

  // MetaMask kontrol√º
  async function checkMetaMask() {
    try {
      if (typeof ethers === 'undefined') {
        connectionStatus.textContent = 'Loading Web3 libraries...';
        setTimeout(checkMetaMask, 1000);
        return;
      }

      if (typeof window.ethereum !== 'undefined') {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        connectWalletBtn.textContent = 'Connect MetaMask';
        connectWalletBtn.disabled = false;
        
        try {
          const accounts = await window.ethereum.request({ method: 'eth_accounts' });
          if (accounts.length > 0) {
            currentAccount = accounts[0];
            signer = provider.getSigner();
            showNFTSelection();
          } else {
            connectionStatus.textContent = 'Please connect your MetaMask wallet.';
          }
        } catch (error) {
          connectionStatus.textContent = 'Please connect your MetaMask wallet.';
        }
      } else {
        connectionStatus.textContent = 'MetaMask is not installed. Please install MetaMask to continue.';
        connectWalletBtn.textContent = 'Install MetaMask';
        connectWalletBtn.onclick = () => window.open('https://metamask.io/', '_blank');
      }
    } catch (error) {
      console.error('MetaMask check error:', error);
      connectionStatus.textContent = 'Error checking MetaMask. Please refresh the page.';
    }
  }

  // MetaMask'a baƒülanma fonksiyonu
  async function connectWallet() {
    try {
      if (typeof ethers === 'undefined') {
        connectionStatus.textContent = 'Web3 libraries not loaded. Please refresh the page.';
        return;
      }

      connectWalletBtn.disabled = true;
      connectWalletBtn.textContent = 'Connecting...';
      
      const accounts = await window.ethereum.request({
        method: 'eth_requestAccounts',
      });
      
      if (accounts.length > 0) {
        currentAccount = accounts[0];
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        showNFTSelection();
      } else {
        throw new Error('No accounts returned');
      }
    } catch (error) {
      console.error('Wallet connection failed:', error);
      connectionStatus.textContent = 'Connection failed. Please try again.';
      connectWalletBtn.disabled = false;
      connectWalletBtn.textContent = 'Connect MetaMask';
    }
  }

  // NFT se√ßim ekranƒ±nƒ± g√∂ster
  async function showNFTSelection() {
    try {
      metamaskContainer.style.display = 'none';
      nftSelectionContainer.style.display = 'flex';
      
      const shortAddress = `${currentAccount.slice(0, 6)}...${currentAccount.slice(-4)}`;
      connectedAddress.textContent = shortAddress;
      walletStatus.style.display = 'block';
      
      await loadUserNFTs();
    } catch (error) {
      console.error('Error showing NFT selection:', error);
      nftError.textContent = 'Error loading NFT selection. Creating demo NFTs...';
      nftError.style.display = 'block';
      createDemoNFTs();
    }
  }

  // Ger√ßek NFT'lerle demo olu≈ütur (ger√ßek g√∂r√ºn√ºml√º)
  function createDemoNFTs() {
    const demoCount = 8;
    userNFTs = [];
    
    const nftNames = [
      'Cyber Samurai', 'Digital Warrior', 'Pixel Knight', 'Neon Guardian',
      'Quantum Fighter', 'Tech Assassin', 'Binary Mage', 'Data Paladin'
    ];
    
    for (let i = 1; i <= demoCount; i++) {
      const tokenId = (Math.floor(Math.random() * 9000) + 1000).toString(); // Random 4-digit token ID
      const nft = {
        tokenId: tokenId,
        name: nftNames[i - 1] || `Warrior #${tokenId}`,
        image: generateNFTImageURL(tokenId),
        traits: [
          { trait_type: "Strength", value: (Math.random() * 100).toFixed(0) },
          { trait_type: "Speed", value: (Math.random() * 100).toFixed(0) },
          { trait_type: "Power", value: (Math.random() * 100).toFixed(0) },
          { trait_type: "Defense", value: (Math.random() * 100).toFixed(0) }
        ]
      };
      userNFTs.push(nft);
    }
    
    console.log('Created realistic demo NFTs:', userNFTs);
    displayNFTs();
    nftError.style.display = 'none';
  }

  // Ger√ßek NFT'leri y√ºkleme (blockchain'den)
  async function loadUserNFTs() {
    try {
      nftLoading.style.display = 'flex';
      nftError.style.display = 'none';
      nftGrid.innerHTML = '';
      userNFTs = [];
      
      if (!provider) {
        throw new Error('Provider not initialized');
      }

      console.log('Loading NFTs for address:', currentAccount);
      console.log('Contract address:', NFT_CONTRACT_ADDRESS);
      
      // NFT kontratƒ±na baƒülan
      const nftContract = new ethers.Contract(NFT_CONTRACT_ADDRESS, ERC721_ABI, provider);
      
      try {
        // 5 saniye timeout ile NFT balance kontrol et
        const balancePromise = nftContract.balanceOf(currentAccount);
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Blockchain request timeout')), 5000)
        );
        
        const balance = await Promise.race([balancePromise, timeoutPromise]);
        console.log('NFT Balance:', balance.toString());
        
        if (balance.eq(0)) {
          throw new Error('You don\'t own any NFTs from this collection');
        }
        
        // ƒ∞lk 6 NFT'yi y√ºkle
        const maxLoad = Math.min(balance.toNumber(), 6);
        const loadPromises = [];
        
        for (let i = 0; i < maxLoad; i++) {
          const promise = loadSingleNFT(nftContract, i).catch(error => {
            console.error(`Error loading NFT ${i}:`, error);
            return null;
          });
          loadPromises.push(promise);
        }
        
        // 10 saniye timeout ile NFT'leri y√ºkle
        const timeoutAllPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('NFT loading timeout')), 10000)
        );
        
        const results = await Promise.race([
          Promise.allSettled(loadPromises),
          timeoutAllPromise
        ]);
        
        if (Array.isArray(results)) {
          userNFTs = results
            .filter(result => result.status === 'fulfilled' && result.value !== null)
            .map(result => result.value);
        }
        
        if (userNFTs.length === 0) {
          throw new Error('Could not load any NFT metadata');
        }
        
        console.log('Successfully loaded NFTs:', userNFTs.length);
        displayNFTs();
        
      } catch (blockchainError) {
        console.error('Blockchain error:', blockchainError);
        throw new Error('Failed to load NFTs from blockchain. Using demo NFTs.');
      }
      
    } catch (error) {
      console.error('Error loading NFTs:', error);
      nftError.innerHTML = `
        <strong>‚ö†Ô∏è NFT Loading Error</strong><br>
        ${error.message}<br>
        <small>Using demo NFTs for testing...</small>
      `;
      nftError.style.display = 'block';
      
      setTimeout(() => {
        createDemoNFTs();
      }, 1500);
      
    } finally {
      nftLoading.style.display = 'none';
    }
  }

  // Tek NFT y√ºkleme fonksiyonu
  async function loadSingleNFT(contract, index) {
    const tokenId = await contract.tokenOfOwnerByIndex(currentAccount, index);
    
    const nft = {
      tokenId: tokenId.toString(),
      name: `NFT #${tokenId.toString()}`,
      description: `Warrior from the collection`,
      image: generateNFTImageURL(tokenId.toString()),
      traits: []
    };
    
    // Token URI'yi almaya √ßalƒ±≈ü (kƒ±sa timeout ile)
    try {
      const uriPromise = contract.tokenURI(tokenId);
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('URI timeout')), 3000)
      );
      
      const tokenURI = await Promise.race([uriPromise, timeoutPromise]);
      
      if (tokenURI && (tokenURI.startsWith('http') || tokenURI.startsWith('ipfs'))) {
        let metadataURL = tokenURI;
        if (tokenURI.startsWith('ipfs://')) {
          metadataURL = tokenURI.replace('ipfs://', 'https://ipfs.io/ipfs/');
        }
        
        const response = await fetch(metadataURL, { 
          signal: AbortSignal.timeout(3000) 
        });
        const metadata = await response.json();
        
        nft.name = metadata.name || nft.name;
        nft.description = metadata.description || nft.description;
        
        if (metadata.image) {
          let imageURL = metadata.image;
          if (imageURL.startsWith('ipfs://')) {
            imageURL = imageURL.replace('ipfs://', 'https://ipfs.io/ipfs/');
          }
          nft.image = imageURL;
        }
        
        nft.traits = metadata.attributes || [];
      }
    } catch (uriError) {
      console.log('Token URI error for token', tokenId.toString(), ':', uriError);
      // Varsayƒ±lan deƒüerlerle devam et
    }
    
    return nft;
  }

  // NFT'leri ekranda g√∂ster
  function displayNFTs() {
    nftGrid.innerHTML = '';
    
    userNFTs.forEach((nft, index) => {
      const stats = calculateNFTStats(nft);
      
      const nftCard = document.createElement('div');
      nftCard.className = 'nft-card';
      nftCard.dataset.index = index;
      
      nftCard.innerHTML = `
        <img src="${nft.image}" alt="${nft.name}" class="nft-image" 
             onerror="this.src='${generateNFTImageURL(nft.tokenId)}'" />
        <div class="nft-info">
          <div style="font-weight: bold; margin-bottom: 5px; font-size: 12px;">${nft.name}</div>
          <div style="font-size: 10px; color: #aaa; margin-bottom: 5px;">${nft.rarity || 'Common'}</div>
          <div class="nft-stats">
            <span class="stat health-stat" style="font-size: 9px; padding: 1px 3px;">‚ù§Ô∏è ${stats.health}</span>
            <span class="stat attack-stat" style="font-size: 9px; padding: 1px 3px;">‚öîÔ∏è ${stats.attack}</span>
          </div>
          <div class="nft-stats">
            <span class="stat defense-stat" style="font-size: 9px; padding: 1px 3px;">üõ°Ô∏è ${stats.defense}</span>
            <span class="stat speed-stat" style="font-size: 9px; padding: 1px 3px;">‚ö° ${stats.speed}</span>
          </div>
        </div>
      `;
      
      nftCard.addEventListener('click', () => selectNFTCard(index));
      nftGrid.appendChild(nftCard);
    });
  }

  // NFT kartƒ± se√ßimi
  function selectNFTCard(index) {
    document.querySelectorAll('.nft-card').forEach(card => {
      card.classList.remove('selected');
    });
    
    const selectedCard = document.querySelector(`[data-index="${index}"]`);
    if (selectedCard) {
      selectedCard.classList.add('selected');
      selectedNFT = userNFTs[index];
      selectNFTBtn.disabled = false;
    }
  }

  // NFT se√ßimini onayla ve oyuna ba≈üla
  function confirmNFTSelection() {
    if (selectedNFT) {
      nftSelectionContainer.style.display = 'none';
      gameContainer.style.display = 'flex';
      initializeGame();
    }
  }

  // NFT'leri yenile
  async function refreshNFTs() {
    selectedNFT = null;
    selectNFTBtn.disabled = true;
    await loadUserNFTs();
  }

  // Hesap deƒüi≈üikliƒüi dinleyicisi
  if (window.ethereum) {
    window.ethereum.on('accountsChanged', (accounts) => {
      if (accounts.length === 0) {
        currentAccount = null;
        selectedNFT = null;
        provider = null;
        signer = null;
        walletStatus.style.display = 'none';
        gameContainer.style.display = 'none';
        nftSelectionContainer.style.display = 'none';
        metamaskContainer.style.display = 'flex';
        if (socket) {
          socket.disconnect();
        }
      } else if (accounts[0] !== currentAccount) {
        currentAccount = accounts[0];
        selectedNFT = null;
        if (provider) {
          signer = provider.getSigner();
          showNFTSelection();
        }
      }
    });
  }

  // Event listeners
  window.addEventListener('load', () => {
    setTimeout(checkMetaMask, 1000);
  });
  
  connectWalletBtn.addEventListener('click', connectWallet);
  selectNFTBtn.addEventListener('click', confirmNFTSelection);
  refreshNFTsBtn.addEventListener('click', refreshNFTs);

  // Oyun ba≈ülatma fonksiyonu
  function initializeGame() {
    console.log('Starting game with NFT:', selectedNFT);
    
    // Backend URL ile Socket baƒülantƒ±sƒ±
    socket = io(BACKEND_URL, {
      transports: ['websocket', 'polling'],
      upgrade: true,
      rememberUpgrade: true
    });

    // Se√ßilen NFT'nin statlarƒ±nƒ± hesapla
    yourNFTStats = calculateNFTStats(selectedNFT);
    
    // NFT bilgilerini g√∂ster
    document.getElementById('your-nft-info').textContent = selectedNFT.name;
    document.getElementById('your-base-health').textContent = yourNFTStats.health;
    document.getElementById('your-attack').textContent = yourNFTStats.attack;
    document.getElementById('your-defense').textContent = yourNFTStats.defense;
    
    // NFT avatarƒ±nƒ± ayarla
    document.getElementById('player-avatar').src = selectedNFT.image;

    // Oyun durumu g√ºncellemeleri
    function updateBars() {
      if(!yourData || !enemyData) return;

      const yourMaxHealth = yourNFTStats ? yourNFTStats.health : 200;
      const enemyMaxHealth = enemyNFTStats ? enemyNFTStats.health : 200;
      
      const yourHealthPercent = (yourData.health / yourMaxHealth) * 100;
      const enemyHealthPercent = (enemyData.health / enemyMaxHealth) * 100;
      
      youHealthBar.style.width = Math.max(0, yourHealthPercent) + '%';
      enemyHealthBar.style.width = Math.max(0, enemyHealthPercent) + '%';

      youManaBar.style.width = (yourData.mana / 100 * 100) + '%';
      enemyManaBar.style.width = (enemyData.mana / 100 * 100) + '%';

      youHealthLabel.textContent = `Health: ${yourData.health}/${yourMaxHealth}`;
      enemyHealthLabel.textContent = `Health: ${enemyData.health}/${enemyMaxHealth}`;

      youManaLabel.textContent = `Mana: ${yourData.mana}/100`;
      enemyManaLabel.textContent = `Mana: ${enemyData.mana}/100`;
    }

    function updateButtonStatus() {
      const disabled = !yourTurn || !gameActive;
      
      attackBtn.disabled = disabled || (yourData && yourData.mana < 10);
      defendBtn.disabled = disabled || (yourData && yourData.mana < 5);
      skillBtn.disabled = disabled || (yourData && yourData.mana < 20);
      hydraBtn.disabled = disabled || (yourData && yourData.mana < 30) || (yourData && yourData.hydraUsed);
      manaBtn.disabled = disabled;
    }

    // Socket event handlers
    socket.on('connect', () => {
      console.log('Connected to server:', BACKEND_URL);
      addChatMessage('üîó Connected to server', 'system');
      
      // NFT ile oyuna katƒ±l
      socket.emit('playerMove', { 
        move: 'join',
        walletAddress: currentAccount,
        selectedNFT: selectedNFT
      });
    });

    socket.on('disconnect', () => {
      console.log('Disconnected from server');
      addChatMessage('‚ùå Disconnected from server', 'system');
    });

    socket.on('connect_error', (error) => {
      console.error('Connection error:', error);
      addChatMessage('‚ö†Ô∏è Connection error. Retrying...', 'system');
    });

    socket.on('waitingForOpponent', () => {
      statusDiv.textContent = '‚è≥ Waiting for opponent...';
      addChatMessage('‚è≥ Waiting for opponent...', 'system');
    });

    socket.on('gameStart', (data) => {
      console.log('Game started:', data);
      
      yourIndex = data.yourIndex;
      yourData = data.you;
      enemyData = data.enemy;
      gameActive = true;
      yourTurn = data.yourTurn || false;
      
      // Enemy NFT bilgilerini g√∂ster
      if (data.enemyNFT) {
        enemyNFTStats = calculateNFTStats(data.enemyNFT);
        document.getElementById('enemy-nft-info').textContent = data.enemyNFT.name;
        document.getElementById('enemy-base-health').textContent = enemyNFTStats.health;
        document.getElementById('enemy-attack').textContent = enemyNFTStats.attack;
        document.getElementById('enemy-defense').textContent = enemyNFTStats.defense;
        document.getElementById('enemy-avatar').src = data.enemyNFT.image;
      }
      
      updateBars();
      updateButtonStatus();
      
      statusDiv.textContent = yourTurn ? '‚öîÔ∏è Your turn!' : '‚è≥ Enemy\'s turn';
      addChatMessage('üéÆ Game started! Battle begins!', 'system');
    });

    socket.on('moveConfirmed', (data) => {
      yourData = data.you;
      enemyData = data.enemy;
      yourTurn = data.yourTurn || false;
      
      updateBars();
      updateButtonStatus();
      statusDiv.textContent = yourTurn ? '‚öîÔ∏è Your turn!' : '‚è≥ Enemy\'s turn';
    });

    socket.on('enemyMove', (data) => {
      yourData = data.you;
      enemyData = data.enemy;
      yourTurn = data.yourTurn || true;
      
      updateBars();
      updateButtonStatus();
      statusDiv.textContent = yourTurn ? '‚öîÔ∏è Your turn!' : '‚è≥ Enemy\'s turn';
      
      // Enemy hareket mesajƒ±
      addChatMessage(`üéØ Enemy used ${data.move}!`, 'system');
    });

    socket.on('gameOver', (data) => {
      gameActive = false;
      updateButtonStatus();
      
      if (data.winner === 'player') {
        victoryMessage.textContent = 'üéâ Victory!';
        victoryMessage.style.color = '#2ecc71';
      } else {
        victoryMessage.textContent = 'üíÄ Defeat!';
        victoryMessage.style.color = '#e74c3c';
      }
      
      victoryMessage.style.display = 'block';
      backToMenuBtn.style.display = 'block';
      playAgainBtn.style.display = 'block';
      
      statusDiv.textContent = 'Game Over';
      addChatMessage(`üèÅ Game Over - ${data.winner === 'player' ? 'You Win!' : 'You Lose!'}`, 'system');
    });

    socket.on('chatMessage', (data) => {
      const sender = data.fromIndex === yourIndex ? 'you' : 'enemy';
      addChatMessage(data.message, sender);
    });

    socket.on('errorMessage', (message) => {
      addChatMessage(`‚ùå Error: ${message}`, 'system');
    });

    // Button event listeners
    attackBtn.addEventListener('click', () => {
      if (yourTurn && gameActive) {
        socket.emit('playerMove', { move: 'attack' });
        addChatMessage('‚öîÔ∏è You used Attack!', 'you');
      }
    });

    defendBtn.addEventListener('click', () => {
      if (yourTurn && gameActive) {
        socket.emit('playerMove', { move: 'defend' });
        addChatMessage('üõ°Ô∏è You used Defend!', 'you');
      }
    });

    skillBtn.addEventListener('click', () => {
      if (yourTurn && gameActive) {
        socket.emit('playerMove', { move: 'skill' });
        addChatMessage('‚ú® You used Skill!', 'you');
      }
    });

    manaBtn.addEventListener('click', () => {
      if (yourTurn && gameActive) {
        socket.emit('playerMove', { move: 'mana' });
        addChatMessage('üí´ You restored Mana!', 'you');
      }
    });

    hydraBtn.addEventListener('click', () => {
      if (yourTurn && gameActive) {
        socket.emit('playerMove', { move: 'hydra' });
        addChatMessage('üê≤ You used Ultimate!', 'you');
      }
    });

    // Oyun sonu butonlarƒ±
    backToMenuBtn.addEventListener('click', () => {
      location.reload();
    });

    playAgainBtn.addEventListener('click', () => {
      victoryMessage.style.display = 'none';
      backToMenuBtn.style.display = 'none';
      playAgainBtn.style.display = 'none';
      gameActive = false;
      
      socket.emit('playerMove', { 
        move: 'join',
        walletAddress: currentAccount,
        selectedNFT: selectedNFT
      });
    });

    // Chat kontrolleri
    chatInput.addEventListener('input', () => {
      const length = chatInput.value.length;
      charCount.textContent = `${length}/20`;
      chatSendBtn.disabled = length === 0;
    });

    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !chatSendBtn.disabled) {
        sendChatMessage();
      }
    });

    chatSendBtn.addEventListener('click', sendChatMessage);

    function sendChatMessage() {
      const message = chatInput.value.trim();
      if (message && socket) {
        socket.emit('chatMessage', { message: message });
        addChatMessage(message, 'you');
        chatInput.value = '';
        charCount.textContent = '0/20';
        chatSendBtn.disabled = true;
      }
    }

    // Chat mesaj fonksiyonu
    function addChatMessage(message, sender = 'system') {
      const messageElement = document.createElement('div');
      messageElement.className = `chat-message ${sender}`;
      messageElement.textContent = message;
      chatMessages.appendChild(messageElement);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
  }
</script>
</body>
</html>
