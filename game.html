<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#2c3e50">
<title>Kryptomon Battle Arena</title>

<!-- Socket.io CDN -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Arial', sans-serif;
    background: url('background.png') center/cover no-repeat fixed,
                linear-gradient(45deg, #8B4513, #D2691E);
    color: #fff;
    overflow: hidden;
    height: 100vh;
  }

  /* Dynamic backgrounds */
  body.bg1 {
    background: url('background.png') center/cover no-repeat fixed;
  }
  
  body.bg2 {
    background: url('background2.png') center/cover no-repeat fixed;
  }
  
  body.bg3 {
    background: url('background3.png') center/cover no-repeat fixed;
  }

  body.bg4 {
    background: url('background4.png') center/cover no-repeat fixed;
  }

  /* Connection Status */
  .connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    z-index: 9999;
    transition: all 0.3s ease;
  }

  .connection-status.connected {
    background: #2ecc71;
    color: white;
  }

  .connection-status.disconnected {
    background: #e74c3c;
    color: white;
  }

  .connection-status.connecting {
    background: #f39c12;
    color: white;
  }

  .connection-status.error {
    background: #e74c3c;
    color: white;
  }

  /* Screen Rotation Prompt */
  .rotation-prompt {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.95);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    flex-direction: column;
    color: white;
    text-align: center;
  }

  .rotation-icon {
    font-size: 80px;
    margin-bottom: 20px;
    animation: rotatePhone 2s infinite ease-in-out;
  }

  @keyframes rotatePhone {
    0%, 100% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
  }

  /* Player Name Selection Screen */
  #player-name-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }

  #player-name-modal {
    background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 25px 50px rgba(0,0,0,0.5);
  }

  #player-name-input {
    width: 100%;
    padding: 15px;
    font-size: 18px;
    border: 2px solid #3498db;
    border-radius: 10px;
    margin: 20px 0;
    background: rgba(255,255,255,0.9);
    color: #2c3e50;
    text-align: center;
  }

  #player-name-input:focus {
    outline: none;
    border-color: #2ecc71;
    box-shadow: 0 0 15px rgba(46, 204, 113, 0.3);
  }

  #set-name-btn {
    background: linear-gradient(45deg, #2ecc71, #27ae60);
    color: white;
    border: none;
    padding: 15px 30px;
    border-radius: 10px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    margin: 10px;
    transition: all 0.3s ease;
    width: 100%;
  }

  #set-name-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(46, 204, 113, 0.4);
  }

  #set-name-btn:disabled {
    background: #95a5a6;
    cursor: not-allowed;
    transform: none;
  }

  /* Guest Mode Button */
  #guest-mode-btn {
    background: linear-gradient(45deg, #95a5a6, #7f8c8d);
    color: white;
    border: none;
    padding: 15px 30px;
    border-radius: 10px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
    transition: all 0.3s ease;
    margin-top: 10px;
  }

  #guest-mode-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(149, 165, 166, 0.4);
  }

  /* MetaMask Connection Modal */
  #metamask-container, #nft-selection-container, #waiting-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.95);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }

  #metamask-modal, #nft-selection-modal {
    background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
    padding: 40px;
    border-radius: 20px;
    text-align: center;
    max-width: 900px;
    width: 90%;
    max-height: 85vh;
    overflow-y: auto;
    box-shadow: 0 25px 50px rgba(0,0,0,0.5);
  }

  /* Player name displays */
  .player-name-display {
    font-size: 28px;
    font-weight: bold;
    margin-bottom: 15px;
    color: #FFD700;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
  }

  .game-player-name {
    position: absolute;
    bottom: -50px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    padding: 8px 15px;
    border-radius: 15px;
    font-size: 14px;
    font-weight: bold;
    color: #FFD700;
    border: 2px solid rgba(255,215,0,0.5);
    backdrop-filter: blur(5px);
  }

  .trainer.left .game-player-name {
    left: 30px;
    transform: none;
  }

  .trainer.right .game-player-name {
    right: 30px;
    left: auto;
    transform: none;
  }

  /* Waiting for Opponent Screen */
  #waiting-container {
    background: linear-gradient(45deg, rgba(0,0,0,0.8), rgba(50,50,50,0.9));
    backdrop-filter: blur(10px);
  }

  .waiting-screen {
    text-align: center;
    color: #fff;
    width: 100%;
    height: 100%;
    position: relative;
  }

  .waiting-split {
    display: flex;
    width: 100%;
    height: 100vh;
    position: relative;
  }

  .waiting-left, .waiting-right {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    position: relative;
    padding: 50px 20px;
  }

  .waiting-left {
    background: linear-gradient(45deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.5));
    border-right: 4px solid rgba(255,255,255,0.3);
  }

  .waiting-right {
    background: linear-gradient(45deg, rgba(231, 76, 60, 0.3), rgba(192, 57, 43, 0.5));
  }

  .vs-divider {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 100px;
    color: #FFD700;
    text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
    z-index: 10;
    animation: pulse 2s infinite;
  }

  .waiting-player-icon {
    font-size: 120px;
    margin-bottom: 20px;
    animation: bounce 2s infinite;
  }

  .waiting-player-name {
    font-size: 24px;
    font-weight: bold;
    margin-bottom: 15px;
    color: #FFD700;
  }

  .waiting-status {
    font-size: 18px;
    margin-bottom: 20px;
  }

  .question-mark {
    font-size: 150px;
    color: #ccc;
    margin-bottom: 20px;
    animation: bounce 2s infinite;
  }

  /* Game Start Countdown */
  .game-start-countdown {
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 120px;
    color: #FFD700;
    font-weight: bold;
    text-shadow: 0 0 40px rgba(255, 215, 0, 1);
    z-index: 5000;
    animation: countdownPulse 1s infinite;
    background: rgba(0,0,0,0.9);
    padding: 30px 50px;
    border-radius: 25px;
    border: 4px solid #FFD700;
    backdrop-filter: blur(10px);
  }

  @keyframes countdownPulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
  }

  @keyframes bounce {
    0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
    40% { transform: translateY(-20px); }
    60% { transform: translateY(-10px); }
  }

  @keyframes pulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
  }

  #connect-wallet-btn, #select-nft-btn, #refresh-nfts-btn {
    background: linear-gradient(45deg, #f6851b, #ff6b35);
    color: white;
    border: none;
    padding: 15px 30px;
    border-radius: 10px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    margin: 10px;
    transition: all 0.3s ease;
  }

  #connect-wallet-btn:hover, #select-nft-btn:hover, #refresh-nfts-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(246, 133, 27, 0.4);
  }

  /* NFT Selection Grid */
  #nft-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 20px;
    margin: 25px 0;
  }

  .nft-card {
    background: rgba(60, 60, 60, 0.9);
    border-radius: 15px;
    padding: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 3px solid transparent;
  }

  .nft-card:hover {
    transform: translateY(-5px);
    border-color: #3498db;
  }

  .nft-card.selected {
    border-color: #2ecc71;
    background: rgba(46, 204, 113, 0.2);
  }

  .nft-image {
    width: 100%;
    height: 160px;
    object-fit: cover;
    border-radius: 10px;
    margin-bottom: 10px;
    background: #333;
  }

  /* Game Arena */
  #game-container {
    width: 100vw;
    height: 100vh;
    position: relative;
    display: none;
  }

  .dojo-bg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.4) 100%);
    backdrop-filter: blur(1px);
  }

  /* Turn Info */
  .turn-info {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.9);
    color: white;
    padding: 10px 20px;
    border-radius: 25px;
    font-size: 16px;
    font-weight: bold;
    backdrop-filter: blur(10px);
    border: 2px solid #FFD700;
    z-index: 100;
    text-align: center;
  }

  .turn-timer {
    color: #FFD700;
    font-size: 18px;
    margin-top: 5px;
  }

  /* HP Bars - Top of screen */
  .hp-bar-container {
    position: absolute;
    top: 80px;
    background: rgba(0,0,0,0.9);
    padding: 15px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255,255,255,0.2);
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 15px;
    min-width: 300px;
  }

  .hp-bar-container.left {
    left: 30px;
  }

  .hp-bar-container.right {
    right: 30px;
  }

  .hp-kryptomon-image {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 3px solid #FFD700;
    object-fit: cover;
    background: #333;
  }

  .hp-stats {
    flex: 1;
  }

  .hp-stat {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    gap: 10px;
  }

  .hp-stat:last-child {
    margin-bottom: 0;
  }

  .hp-stat-icon {
    width: 24px;
    height: 24px;
    background: linear-gradient(45deg, #e74c3c, #c0392b);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 12px;
    font-weight: bold;
  }

  .hp-stat-icon::before {
    content: '‚ù§Ô∏è';
  }

  .hp-stat-value {
    color: white;
    font-weight: bold;
    min-width: 80px;
    text-align: left;
  }

  .hp-bar-modern {
    background: rgba(255,255,255,0.2);
    height: 20px;
    border-radius: 10px;
    overflow: hidden;
    flex: 1;
    position: relative;
  }

  .hp-fill-modern {
    background: linear-gradient(90deg, #e74c3c 0%, #27ae60 100%);
    height: 100%;
    transition: width 0.5s ease;
    border-radius: 10px;
  }

  /* Character Images with Profile Photos */
  .character-image {
    position: absolute;
    bottom: 20px;
    background: rgba(0,0,0,0.9);
    padding: 15px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255,255,255,0.2);
    z-index: 100;
    min-width: 300px;
    display: flex;
    align-items: center;
    gap: 15px;
  }

  .character-image.left {
    left: 30px;
  }

  .character-image.right {
    right: 30px;
  }

  .character-profile-image {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: 3px solid #FFD700;
    object-fit: cover;
    background: #333;
  }

  .character-info {
    flex: 1;
  }

  .character-mana {
    margin-top: 10px;
  }

  .mana-stat {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .mana-stat-icon {
    width: 24px;
    height: 24px;
    background: linear-gradient(45deg, #3498db, #2980b9);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 12px;
    font-weight: bold;
  }

  .mana-stat-icon::before {
    content: '‚ö°';
  }

  /* Mana sadece rakam olacak */
  .mana-stat-value {
    color: #3498db;
    font-weight: bold;
    font-size: 24px;
    text-align: center;
    min-width: 60px;
  }

  /* Battle Arena */
  .battle-arena {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 60%;
    height: 40%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 50;
  }

  .trainer {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .kryptomon-sprite {
    width: 200px;
    height: 200px;
    object-fit: contain;
    transition: all 0.3s ease;
    filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
  }

  /* Sol taraftaki Kryptomon saƒüa baksƒ±n (normal), saƒü taraftaki sola baksƒ±n (flipped) */
  .trainer.right .kryptomon-sprite {
    transform: scaleX(-1);
  }

  /* Attack Animations */
  .attack-animation {
    animation: attackMove 0.6s ease-in-out;
  }

  .skill-animation {
    animation: skillShake 0.8s ease-in-out;
  }

  .ultimate-animation {
    animation: ultimateBlast 1.2s ease-in-out;
  }

  @keyframes attackMove {
    0% { transform: translateX(0); }
    30% { transform: translateX(50px); }
    100% { transform: translateX(0); }
  }

  .trainer.right .attack-animation {
    animation: attackMoveRight 0.6s ease-in-out;
  }

  @keyframes attackMoveRight {
    0% { transform: translateX(0) scaleX(-1); }
    30% { transform: translateX(-50px) scaleX(-1); }
    100% { transform: translateX(0) scaleX(-1); }
  }

  @keyframes skillShake {
    0%, 100% { transform: translateX(0) rotate(0deg); }
    25% { transform: translateX(-10px) rotate(-5deg); }
    75% { transform: translateX(10px) rotate(5deg); }
  }

  .trainer.right .skill-animation {
    animation: skillShakeRight 0.8s ease-in-out;
  }

  @keyframes skillShakeRight {
    0%, 100% { transform: translateX(0) scaleX(-1) rotate(0deg); }
    25% { transform: translateX(10px) scaleX(-1) rotate(5deg); }
    75% { transform: translateX(-10px) scaleX(-1) rotate(-5deg); }
  }

  @keyframes ultimateBlast {
    0% { transform: scale(1) rotate(0deg); filter: brightness(1) drop-shadow(0 10px 20px rgba(0,0,0,0.5)); }
    25% { transform: scale(1.3) rotate(10deg); filter: brightness(2) drop-shadow(0 0 30px rgba(255,215,0,0.8)); }
    50% { transform: scale(0.8) rotate(-10deg); filter: brightness(3) drop-shadow(0 0 50px rgba(255,0,0,0.8)); }
    75% { transform: scale(1.2) rotate(5deg); filter: brightness(2.5) drop-shadow(0 0 40px rgba(0,255,255,0.8)); }
    100% { transform: scale(1) rotate(0deg); filter: brightness(1) drop-shadow(0 10px 20px rgba(0,0,0,0.5)); }
  }

  .trainer.right .ultimate-animation {
    animation: ultimateBlastRight 1.2s ease-in-out;
  }

  @keyframes ultimateBlastRight {
    0% { transform: scale(1) scaleX(-1) rotate(0deg); filter: brightness(1) drop-shadow(0 10px 20px rgba(0,0,0,0.5)); }
    25% { transform: scale(1.3) scaleX(-1) rotate(-10deg); filter: brightness(2) drop-shadow(0 0 30px rgba(255,215,0,0.8)); }
    50% { transform: scale(0.8) scaleX(-1) rotate(10deg); filter: brightness(3) drop-shadow(0 0 50px rgba(255,0,0,0.8)); }
    75% { transform: scale(1.2) scaleX(-1) rotate(-5deg); filter: brightness(2.5) drop-shadow(0 0 40px rgba(0,255,255,0.8)); }
    100% { transform: scale(1) scaleX(-1) rotate(0deg); filter: brightness(1) drop-shadow(0 10px 20px rgba(0,0,0,0.5)); }
  }

  /* Kryptomon Switch Animation - geli≈ütirildi */
  .kryptomon-switch-animation {
    animation: magicalSwitchOut 1s ease-in-out;
  }

  .kryptomon-switch-animation.slide-in {
    animation: magicalSwitchIn 1s ease-in-out;
  }

  @keyframes magicalSwitchOut {
    0% {
      transform: scale(1) rotate(0deg);
      opacity: 1;
      filter: brightness(1);
    }
    25% {
      transform: scale(1.2) rotate(90deg);
      opacity: 0.8;
      filter: brightness(2) hue-rotate(180deg);
    }
    50% {
      transform: scale(0.5) rotate(180deg);
      opacity: 0.3;
      filter: brightness(3) hue-rotate(360deg);
    }
    100% {
      transform: scale(0) rotate(360deg);
      opacity: 0;
      filter: brightness(1);
    }
  }

  @keyframes magicalSwitchIn {
    0% {
      transform: scale(0) rotate(-360deg);
      opacity: 0;
      filter: brightness(3) hue-rotate(360deg);
    }
    50% {
      transform: scale(0.5) rotate(-180deg);
      opacity: 0.3;
      filter: brightness(2) hue-rotate(180deg);
    }
    75% {
      transform: scale(1.2) rotate(-90deg);
      opacity: 0.8;
      filter: brightness(1.5) hue-rotate(90deg);
    }
    100% {
      transform: scale(1) rotate(0deg);
      opacity: 1;
      filter: brightness(1);
    }
  }

  .trainer.right .kryptomon-switch-animation {
    animation: magicalSwitchOutRight 1s ease-in-out;
  }

  .trainer.right .kryptomon-switch-animation.slide-in {
    animation: magicalSwitchInRight 1s ease-in-out;
  }

  @keyframes magicalSwitchOutRight {
    0% {
      transform: scale(1) scaleX(-1) rotate(0deg);
      opacity: 1;
      filter: brightness(1);
    }
    25% {
      transform: scale(1.2) scaleX(-1) rotate(-90deg);
      opacity: 0.8;
      filter: brightness(2) hue-rotate(180deg);
    }
    50% {
      transform: scale(0.5) scaleX(-1) rotate(-180deg);
      opacity: 0.3;
      filter: brightness(3) hue-rotate(360deg);
    }
    100% {
      transform: scale(0) scaleX(-1) rotate(-360deg);
      opacity: 0;
      filter: brightness(1);
    }
  }

  @keyframes magicalSwitchInRight {
    0% {
      transform: scale(0) scaleX(-1) rotate(360deg);
      opacity: 0;
      filter: brightness(3) hue-rotate(360deg);
    }
    50% {
      transform: scale(0.5) scaleX(-1) rotate(180deg);
      opacity: 0.3;
      filter: brightness(2) hue-rotate(180deg);
    }
    75% {
      transform: scale(1.2) scaleX(-1) rotate(90deg);
      opacity: 0.8;
      filter: brightness(1.5) hue-rotate(90deg);
    }
    100% {
      transform: scale(1) scaleX(-1) rotate(0deg);
      opacity: 1;
      filter: brightness(1);
    }
  }

  /* Kryptomon Team Selection */
  .kryptomon-team {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 15px;
    z-index: 100;
  }

  .kryptomon-team.left {
    left: 20px;
  }

  .kryptomon-team.right {
    right: 20px;
  }

  .kryptomon-slot {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid rgba(255,255,255,0.3);
    cursor: pointer;
    transition: all 0.3s ease;
    overflow: hidden;
    background: rgba(0,0,0,0.5);
    backdrop-filter: blur(5px);
    position: relative;
  }

  .kryptomon-slot:hover:not(.dead) {
    border-color: #3498db;
    transform: scale(1.1);
  }

  .kryptomon-slot.active {
    border-color: #FFD700;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
  }

  /* Kryptomon √∂l√º durumu */
  .kryptomon-slot.dead {
    opacity: 0.3;
    border-color: #e74c3c;
    cursor: not-allowed;
  }

  .kryptomon-slot.dead::after {
    content: 'üíÄ';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    z-index: 10;
  }

  .kryptomon-slot img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Game Controls */
  .game-controls {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
    z-index: 100;
  }

  .control-btn {
    background: linear-gradient(45deg, #2c3e50, #34495e);
    color: white;
    border: 2px solid rgba(255,255,255,0.3);
    padding: 15px 25px;
    border-radius: 15px;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    position: relative;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
  }

  .control-btn:hover:not(:disabled) {
    transform: translateY(-3px);
    border-color: #3498db;
    box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
  }

  .control-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .control-btn.mana-gain::after {
    content: '+' attr(data-mana);
    position: absolute;
    top: -8px;
    right: -8px;
    background: #2ecc71;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
  }

  .control-btn.mana-cost::after {
    content: '-' attr(data-mana);
    position: absolute;
    top: -8px;
    right: -8px;
    background: #e74c3c;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
  }

  /* Surrender and Emoji Buttons */
  .game-actions {
    position: absolute;
    top: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
    z-index: 200;
  }

  .surrender-btn, .emoji-btn {
    background: rgba(0,0,0,0.8);
    color: white;
    border: 2px solid rgba(255,255,255,0.3);
    width: 50px;
    height: 50px;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .surrender-btn:hover {
    background: #e74c3c;
    border-color: #e74c3c;
  }

  .emoji-btn:hover {
    background: #f39c12;
    border-color: #f39c12;
  }

  /* Emoji Panel */
  .emoji-panel {
    position: absolute;
    top: 80px;
    left: 20px;
    background: rgba(0,0,0,0.9);
    padding: 20px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255,255,255,0.2);
    z-index: 300;
    display: none;
  }

  .emoji-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
  }

  .emoji-item {
    width: 40px;
    height: 40px;
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .emoji-item:hover {
    background: rgba(255,255,255,0.2);
    transform: scale(1.2);
  }

  /* Attack Effects */
  .damage-text {
    position: absolute;
    font-size: 36px;
    font-weight: bold;
    color: #e74c3c;
    text-shadow: 0 0 10px rgba(231, 76, 60, 0.8);
    animation: damageFloat 1.5s ease-out forwards;
    pointer-events: none;
    z-index: 1000;
  }

  .damage-text.critical {
    color: #f39c12;
    font-size: 48px;
    text-shadow: 0 0 15px rgba(243, 156, 18, 1);
    animation: criticalDamageFloat 1.8s ease-out forwards;
  }

  .damage-text.heal {
    color: #2ecc71;
    text-shadow: 0 0 10px rgba(46, 204, 113, 0.8);
  }

  @keyframes damageFloat {
    0% {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    100% {
      opacity: 0;
      transform: translateY(-80px) scale(1.2);
    }
  }

  @keyframes criticalDamageFloat {
    0% {
      opacity: 1;
      transform: translateY(0) scale(1) rotate(0deg);
    }
    25% {
      transform: translateY(-20px) scale(1.3) rotate(5deg);
    }
    50% {
      transform: translateY(-40px) scale(1.1) rotate(-5deg);
    }
    100% {
      opacity: 0;
      transform: translateY(-100px) scale(1.5) rotate(0deg);
    }
  }

  /* Shield Effect - sadece saldƒ±ran kryptomon √ºzerinde g√∂sterilecek */
  .shield-effect {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 250px;
    height: 250px;
    background: radial-gradient(circle, rgba(52, 152, 219, 0.3) 0%, transparent 70%);
    border: 3px solid #3498db;
    border-radius: 50%;
    animation: shieldPulse 0.8s ease-out;
    pointer-events: none;
    z-index: 200;
  }

  @keyframes shieldPulse {
    0% {
      transform: translate(-50%, -50%) scale(0.5);
      opacity: 1;
    }
    100% {
      transform: translate(-50%, -50%) scale(1.2);
      opacity: 0;
    }
  }

  /* Ultimate Effect - geli≈ütirilmi≈ü */
  .ultimate-effect {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, 
      rgba(255, 215, 0, 0.8) 0%, 
      rgba(255, 0, 0, 0.6) 30%, 
      rgba(0, 255, 255, 0.4) 60%, 
      transparent 100%);
    border: 6px solid #FFD700;
    border-radius: 50%;
    animation: ultimateExplosion 1.5s ease-out;
    pointer-events: none;
    z-index: 200;
  }

  .ultimate-effect::before {
    content: '‚≠êüí•‚ö°';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 60px;
    animation: ultimateStars 1.5s ease-out;
  }

  @keyframes ultimateExplosion {
    0% {
      transform: translate(-50%, -50%) scale(0.2) rotate(0deg);
      opacity: 1;
      filter: brightness(3) hue-rotate(0deg);
    }
    25% {
      transform: translate(-50%, -50%) scale(0.8) rotate(90deg);
      opacity: 0.9;
      filter: brightness(4) hue-rotate(90deg);
    }
    50% {
      transform: translate(-50%, -50%) scale(1.2) rotate(180deg);
      opacity: 0.8;
      filter: brightness(5) hue-rotate(180deg);
    }
    75% {
      transform: translate(-50%, -50%) scale(1.5) rotate(270deg);
      opacity: 0.6;
      filter: brightness(3) hue-rotate(270deg);
    }
    100% {
      transform: translate(-50%, -50%) scale(2) rotate(360deg);
      opacity: 0;
      filter: brightness(1) hue-rotate(360deg);
    }
  }

  @keyframes ultimateStars {
    0% {
      transform: translate(-50%, -50%) scale(0) rotate(0deg);
      opacity: 1;
    }
    50% {
      transform: translate(-50%, -50%) scale(2) rotate(180deg);
      opacity: 1;
    }
    100% {
      transform: translate(-50%, -50%) scale(3) rotate(360deg);
      opacity: 0;
    }
  }

  /* Emoji Animation */
  .emoji-animation {
    position: absolute;
    top: 30%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 80px;
    animation: emojiFloat 2s ease-out forwards;
    pointer-events: none;
    z-index: 1000;
  }

  @keyframes emojiFloat {
    0% {
      opacity: 1;
      transform: translate(-50%, -50%) scale(0.5);
    }
    50% {
      transform: translate(-50%, -50%) scale(1.2);
    }
    100% {
      opacity: 0;
      transform: translate(-50%, -50%) scale(1) translateY(-50px);
    }
  }

  /* Mobile Responsive */
  @media (max-width: 768px) {
    .hp-bar-container {
      min-width: 250px;
      padding: 10px;
    }
    
    .character-image {
      min-width: 250px;
      padding: 10px;
    }
    
    .battle-arena {
      width: 80%;
      height: 35%;
    }
    
    .kryptomon-sprite {
      width: 150px;
      height: 150px;
    }
    
    .game-controls {
      flex-wrap: wrap;
      max-width: 90%;
    }
    
    .control-btn {
      padding: 12px 20px;
      font-size: 14px;
    }
    
    .kryptomon-team {
      gap: 10px;
    }
    
    .kryptomon-slot {
      width: 60px;
      height: 60px;
    }
  }

  @media (max-width: 480px) {
    .hp-bar-container {
      min-width: 200px;
      padding: 8px;
      top: 70px;
    }
    
    .character-image {
      min-width: 200px;
      padding: 8px;
      bottom: 15px;
    }
    
    .kryptomon-sprite {
      width: 120px;
      height: 120px;
    }
    
    .game-controls {
      bottom: 20px;
    }
    
    .control-btn {
      padding: 10px 15px;
      font-size: 12px;
    }
    
    .turn-info {
      top: 15px;
      padding: 8px 15px;
      font-size: 14px;
    }
  }
</style>
</head>
<body>
  <!-- Connection Status -->
  <div id="connection-status" class="connection-status disconnected">Disconnected</div>

  <!-- Screen Rotation Prompt -->
  <div class="rotation-prompt" id="rotation-prompt">
    <div class="rotation-icon">üì±</div>
    <h2>Please Rotate Your Device</h2>
    <p>This game is best played in landscape mode</p>
  </div>

  <!-- Player Name Selection Screen -->
  <div id="player-name-container">
    <div id="player-name-modal">
      <h1>üêæ Kryptomon Battle Arena</h1>
      <p>Enter your player name to start battling!</p>
      <input type="text" id="player-name-input" placeholder="Enter your name" maxlength="20">
      <button id="set-name-btn" disabled>Connect Wallet & Select NFTs</button>
      <button id="guest-mode-btn">Play as Guest</button>
    </div>
  </div>

  <!-- MetaMask Connection Modal -->
  <div id="metamask-container">
    <div id="metamask-modal">
      <h2>ü¶ä Connect Your Wallet</h2>
      <p>Connect your MetaMask wallet to access your Kryptomon NFTs</p>
      <button id="connect-wallet-btn">Connect MetaMask</button>
    </div>
  </div>

  <!-- NFT Selection Modal -->
  <div id="nft-selection-container">
    <div id="nft-selection-modal">
      <h2>üéÆ Select Your Kryptomon Team</h2>
      <div class="player-name-display" id="nft-player-name">Player Name</div>
      <p>Choose up to 3 Kryptomon for battle:</p>
      <div id="nft-grid"></div>
      <div style="margin-top: 20px;">
        <button id="refresh-nfts-btn">üîÑ Refresh NFTs</button>
        <button id="select-nft-btn" disabled>Start Battle!</button>
      </div>
    </div>
  </div>

  <!-- Waiting for Opponent Screen -->
  <div id="waiting-container">
    <div class="waiting-screen">
      <div class="waiting-split">
        <div class="waiting-left">
          <div class="waiting-player-icon">üë§</div>
          <div class="waiting-player-name">You</div>
          <div class="waiting-status">Ready!</div>
        </div>
        
        <div class="vs-divider">VS</div>
        
        <div class="waiting-right">
          <div class="question-mark">?</div>
          <div class="waiting-player-name">Looking for opponent...</div>
          <div class="waiting-status">Please wait</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Arena -->
  <div id="game-container">
    <div class="dojo-bg"></div>
    
    <!-- Game Actions -->
    <div class="game-actions">
      <button class="surrender-btn" onclick="surrender()">üè≥Ô∏è</button>
      <button class="emoji-btn" onclick="toggleEmojiPanel()">üòÑ</button>
    </div>
    
    <!-- Emoji Panel -->
    <div class="emoji-panel" id="emoji-panel">
      <div class="emoji-grid">
        <div class="emoji-item" onclick="sendEmoji('üòÑ')">üòÑ</div>
        <div class="emoji-item" onclick="sendEmoji('üòé')">üòé</div>
        <div class="emoji-item" onclick="sendEmoji('üò§')">üò§</div>
        <div class="emoji-item" onclick="sendEmoji('ü§î')">ü§î</div>
        <div class="emoji-item" onclick="sendEmoji('üò±')">üò±</div>
        <div class="emoji-item" onclick="sendEmoji('ü§Ø')">ü§Ø</div>
        <div class="emoji-item" onclick="sendEmoji('üëç')">üëç</div>
        <div class="emoji-item" onclick="sendEmoji('üëé')">üëé</div>
      </div>
    </div>

    <!-- Turn Info -->
    <div class="turn-info">
      <div id="turn-indicator">Your Turn</div>
      <div class="turn-timer" id="turn-timer">30s</div>
    </div>

    <!-- HP Bars -->
    <div class="hp-bar-container left">
      <img src="kryptomon1.png" alt="Your Kryptomon" class="hp-kryptomon-image" id="your-hp-image">
      <div class="hp-stats">
        <div class="hp-stat">
          <div class="hp-stat-icon"></div>
          <div class="hp-stat-value" id="your-hp-text">100/100</div>
          <div class="hp-bar-modern">
            <div class="hp-fill-modern" id="your-hp-fill" style="width: 100%"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="hp-bar-container right">
      <img src="kryptomon2.png" alt="Enemy Kryptomon" class="hp-kryptomon-image" id="enemy-hp-image">
      <div class="hp-stats">
        <div class="hp-stat">
          <div class="hp-stat-icon"></div>
          <div class="hp-stat-value" id="enemy-hp-text">100/100</div>
          <div class="hp-bar-modern">
            <div class="hp-fill-modern" id="enemy-hp-fill" style="width: 100%"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Character Images with Profile Photos -->
    <div class="character-image left">
      <img src="you.jpg" alt="Your Profile" class="character-profile-image">
      <div class="character-info">
        <div class="game-player-name">You</div>
        <div class="character-mana">
          <div class="mana-stat">
            <div class="mana-stat-icon"></div>
            <div class="mana-stat-value" id="your-mana-text">0</div>
          </div>
        </div>
      </div>
    </div>

    <div class="character-image right">
      <img src="enemy.jpg" alt="Enemy Profile" class="character-profile-image">
      <div class="character-info">
        <div class="game-player-name">Opponent</div>
        <div class="character-mana">
          <div class="mana-stat">
            <div class="mana-stat-icon"></div>
            <div class="mana-stat-value" id="enemy-mana-text">0</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Battle Arena -->
    <div class="battle-arena">
      <div class="trainer left">
        <img src="kryptomon1.png" alt="Your Kryptomon" class="kryptomon-sprite" id="player-kryptomon">
        <div class="game-player-name">You</div>
      </div>
      <div class="trainer right">
        <img src="kryptomon2.png" alt="Enemy Kryptomon" class="kryptomon-sprite" id="enemy-kryptomon">
        <div class="game-player-name">Opponent</div>
      </div>
    </div>

    <!-- Kryptomon Team Selection -->
    <div class="kryptomon-team left">
      <div class="kryptomon-slot active" onclick="switchKryptomon(0)">
        <img src="kryptomon1.png" alt="Kryptomon 1">
      </div>
      <div class="kryptomon-slot" onclick="switchKryptomon(1)">
        <img src="kryptomon2.png" alt="Kryptomon 2">
      </div>
      <div class="kryptomon-slot" onclick="switchKryptomon(2)">
        <img src="kryptomon3.png" alt="Kryptomon 3">
      </div>
    </div>

    <div class="kryptomon-team right">
      <div class="kryptomon-slot active">
        <img src="kryptomon4.png" alt="Enemy Kryptomon 1">
      </div>
      <div class="kryptomon-slot">
        <img src="kryptomon5.png" alt="Enemy Kryptomon 2">
      </div>
      <div class="kryptomon-slot">
        <img src="kryptomon6.png" alt="Enemy Kryptomon 3">
      </div>
    </div>

    <!-- Game Controls -->
    <div class="game-controls">
      <button class="control-btn mana-gain" data-mana="2" onclick="playerMove('attack')" id="attack-btn">‚öîÔ∏è Attack</button>
      <button class="control-btn mana-cost" data-mana="2" onclick="playerMove('skill')" id="skill-btn">üî• Skill</button>
      <button class="control-btn mana-cost" data-mana="6" onclick="playerMove('ultimate')" id="ultimate-btn">‚≠ê Ultimate</button>
      <button class="control-btn" onclick="playerMove('defend')" id="defend-btn">üõ°Ô∏è Defend</button>
    </div>
  </div>

<script>
// Global variables
let socket = null;
let gameData = null;
let currentPlayer = null;
let selectedNFTs = [];
let isConnecting = false;
let turnTimer = null;

// Audio Manager
const audioManager = {
  sounds: {},
  
  init() {
    this.sounds.bite = new Audio('bite.mp3');
    this.sounds.skill = new Audio('skill.mp3');
    this.sounds.ultimate = new Audio('ultimate.mp3');
    this.sounds.defense = new Audio('defense.mp3');
    this.sounds.switch = new Audio('switch.mp3');
    this.sounds.victory = new Audio('victory.mp3');
    
    // Set volume
    Object.values(this.sounds).forEach(sound => {
      sound.volume = 0.3;
    });
  },
  
  play(soundName) {
    if (this.sounds[soundName]) {
      this.sounds[soundName].currentTime = 0;
      this.sounds[soundName].play().catch(e => console.log('Audio play failed:', e));
    }
  }
};

// Initialize the game
document.addEventListener('DOMContentLoaded', function() {
  console.log('üéÆ Kryptomon Battle Arena Loading...');
  audioManager.init();
  checkOrientation();
  setupEventListeners();
});

// Screen orientation check
function checkOrientation() {
  const rotationPrompt = document.getElementById('rotation-prompt');
  
  function updateOrientation() {
    if (window.innerWidth < window.innerHeight && window.innerWidth < 768) {
      rotationPrompt.style.display = 'flex';
    } else {
      rotationPrompt.style.display = 'none';
    }
  }
  
  updateOrientation();
  window.addEventListener('resize', updateOrientation);
  window.addEventListener('orientationchange', () => {
    setTimeout(updateOrientation, 100);
  });
}

// Event listeners setup
function setupEventListeners() {
  // Player name input
  const nameInput = document.getElementById('player-name-input');
  const setNameBtn = document.getElementById('set-name-btn');
  const guestModeBtn = document.getElementById('guest-mode-btn');
  
  nameInput.addEventListener('input', function() {
    const name = this.value.trim();
    setNameBtn.disabled = name.length < 2;
    if (name.length >= 2) {
      setNameBtn.textContent = 'Connect Wallet & Select NFTs';
    } else {
      setNameBtn.textContent = 'Enter name (min 2 characters)';
    }
  });
  
  nameInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter' && !setNameBtn.disabled) {
      setNameBtn.click();
    }
  });
  
  setNameBtn.addEventListener('click', function() {
    const playerName = nameInput.value.trim();
    if (playerName.length >= 2) {
      currentPlayer = {
        playerName: playerName,
        isGuestMode: false
      };
      connectWallet();
    }
  });
  
  // Guest mode d√ºzeltildi
  guestModeBtn.addEventListener('click', function() {
    const playerName = nameInput.value.trim() || 'Guest';
    currentPlayer = {
      playerName: playerName,
      isGuestMode: true,
      walletAddress: 'guest_' + Math.random().toString(36).substr(2, 9)
    };
    generateDefaultNFTs();
  });
  
  // Wallet connection
  document.getElementById('connect-wallet-btn').addEventListener('click', function() {
    connectMetaMask();
  });
  
  // NFT selection
  document.getElementById('refresh-nfts-btn').addEventListener('click', function() {
    if (currentPlayer && !currentPlayer.isGuestMode) {
      loadNFTs();
    } else {
      generateDefaultNFTs();
    }
  });
  
  document.getElementById('select-nft-btn').addEventListener('click', function() {
    startMatchmaking();
  });
}

// Hide all screens
function hideAllScreens() {
  document.getElementById('player-name-container').style.display = 'none';
  document.getElementById('metamask-container').style.display = 'none';
  document.getElementById('nft-selection-container').style.display = 'none';
  document.getElementById('waiting-container').style.display = 'none';
  document.getElementById('game-container').style.display = 'none';
}

// Set game background
function setGameBackground(backgroundFile) {
  if (!backgroundFile) return;
  
  document.body.className = ''; // Clear existing classes
  
  if (backgroundFile.includes('background2')) {
    document.body.className = 'bg2';
  } else if (backgroundFile.includes('background3')) {
    document.body.className = 'bg3';
  } else if (backgroundFile.includes('background4')) {
    document.body.className = 'bg4';
  } else {
    document.body.className = 'bg1';
  }
}

// Update player names in game
function updatePlayerNames() {
  const leftPlayerNames = document.querySelectorAll('.trainer.left .game-player-name');
  const rightPlayerNames = document.querySelectorAll('.trainer.right .game-player-name');
  
  leftPlayerNames.forEach(element => {
    element.textContent = gameData.playerName || 'You';
  });
  
  rightPlayerNames.forEach(element => {
    element.textContent = gameData.opponentName || 'Opponent';
  });
}

// Wallet connection functions
async function connectWallet() {
  hideAllScreens();
  document.getElementById('metamask-container').style.display = 'flex';
}

async function connectMetaMask() {
  try {
    if (typeof window.ethereum !== 'undefined') {
      const accounts = await window.ethereum.request({ 
        method: 'eth_requestAccounts' 
      });
      
      if (accounts.length > 0) {
        currentPlayer.walletAddress = accounts[0];
        console.log('‚úÖ Wallet connected:', accounts[0]);
        loadNFTs();
      }
    } else {
      alert('MetaMask not found! Please install MetaMask or use Guest Mode.');
      document.getElementById('player-name-container').style.display = 'flex';
      document.getElementById('metamask-container').style.display = 'none';
    }
  } catch (error) {
    console.error('‚ùå Wallet connection failed:', error);
    alert('Failed to connect wallet. Please try again or use Guest Mode.');
    document.getElementById('player-name-container').style.display = 'flex';
    document.getElementById('metamask-container').style.display = 'none';
  }
}

// NFT loading functions
async function loadNFTs() {
  hideAllScreens();
  document.getElementById('nft-selection-container').style.display = 'flex';
  document.getElementById('nft-player-name').textContent = currentPlayer.playerName;
  
  // Generate default NFTs for demo
  generateDefaultNFTs();
}

function generateDefaultNFTs() {
  const nftGrid = document.getElementById('nft-grid');
  nftGrid.innerHTML = '';
  
  const defaultNFTs = [];
  
  for (let i = 1; i <= 9; i++) {
    const nft = {
      tokenId: (977 + i).toString(),
      name: `Kryptomon #${977 + i}`,
      image: `kryptomon${i}.png`,
      stats: calculateStats(977 + i)
    };
    defaultNFTs.push(nft);
    
    const nftCard = createNFTCard(nft, i - 1);
    nftGrid.appendChild(nftCard);
  }
  
  console.log('üéÆ Generated default NFTs:', defaultNFTs.length);
}

function calculateStats(tokenId) {
  const tokenNum = parseInt(tokenId) || 0;
  
  let health = 100 + (tokenNum * 3) % 50;
  let attack = 15 + (tokenNum * 5) % 20;
  let defense = 10 + (tokenNum * 7) % 15;
  let speed = 12 + (tokenNum * 11) % 18;
  
  return {
    health: Math.min(health, 150),
    attack: Math.min(attack, 35),
    defense: Math.min(defense, 25),
    speed: Math.min(speed, 30)
  };
}

function createNFTCard(nft, index) {
  const card = document.createElement('div');
  card.className = 'nft-card';
  card.dataset.index = index;
  
  card.innerHTML = `
    <img src="${nft.image}" alt="${nft.name}" class="nft-image" loading="lazy">
    <h3>${nft.name}</h3>
    <div class="nft-stats">
      <div>‚ù§Ô∏è HP: ${nft.stats.health}</div>
      <div>‚öîÔ∏è ATK: ${nft.stats.attack}</div>
      <div>üõ°Ô∏è DEF: ${nft.stats.defense}</div>
      <div>‚ö° SPD: ${nft.stats.speed}</div>
    </div>
  `;
  
  card.addEventListener('click', function() {
    toggleNFTSelection(this, nft, index);
  });
  
  return card;
}

function toggleNFTSelection(cardElement, nft, index) {
  const isSelected = cardElement.classList.contains('selected');
  
  if (isSelected) {
    // Deselect
    cardElement.classList.remove('selected');
    selectedNFTs = selectedNFTs.filter(n => n.tokenId !== nft.tokenId);
  } else {
    // Select (max 3)
    if (selectedNFTs.length < 3) {
      cardElement.classList.add('selected');
      selectedNFTs.push(nft);
    } else {
      alert('You can select maximum 3 Kryptomon!');
      return;
    }
  }
  
  // Update button state
  const selectBtn = document.getElementById('select-nft-btn');
  if (selectedNFTs.length > 0) {
    selectBtn.disabled = false;
    selectBtn.textContent = `Start Battle! (${selectedNFTs.length}/3 selected)`;
  } else {
    selectBtn.disabled = true;
    selectBtn.textContent = 'Select at least 1 Kryptomon';
  }
  
  console.log('üéØ Selected NFTs:', selectedNFTs.length);
}

// Matchmaking functions
function startMatchmaking() {
  if (selectedNFTs.length === 0) {
    alert('Please select at least 1 Kryptomon!');
    return;
  }
  
  // Ensure we have exactly 3 Kryptomon (fill with defaults if needed)
  while (selectedNFTs.length < 3) {
    const defaultNft = {
      tokenId: (978 + selectedNFTs.length).toString(),
      name: `Default Kryptomon ${selectedNFTs.length + 1}`,
      image: `kryptomon${selectedNFTs.length + 1}.png`,
      stats: calculateStats(978 + selectedNFTs.length)
    };
    selectedNFTs.push(defaultNft);
  }
  
  currentPlayer.selectedKryptomon = selectedNFTs;
  
  console.log('üéØ Starting matchmaking with:', currentPlayer);
  
  initializeSocket();
}

// Socket connection and game logic
function initializeSocket() {
  if (socket) {
    socket.disconnect();
  }
  
  updateConnectionStatus('connecting');
  
  // Connect to the server
  socket = io('https://pvpbackend.onrender.com', {
    transports: ['websocket', 'polling'],
    timeout: 20000,
    forceNew: true
  });
  
  socket.on('connect', () => {
    console.log('‚úÖ Connected to game server');
    updateConnectionStatus('connected');
    
    // Send match request
    socket.emit('findMatch', {
      playerName: currentPlayer.playerName,
      walletAddress: currentPlayer.walletAddress,
      selectedKryptomon: currentPlayer.selectedKryptomon,
      isGuestMode: currentPlayer.isGuestMode
    });
  });
  
  socket.on('disconnect', () => {
    console.log('‚ùå Disconnected from server');
    updateConnectionStatus('disconnected');
  });
  
  socket.on('connect_error', (error) => {
    console.error('‚ùå Connection error:', error);
    updateConnectionStatus('error');
  });
  
  // Game events
  socket.on('waitingForOpponent', (data) => {
    console.log('‚è≥ Waiting for opponent:', data);
    showWaitingScreen();
  });
  
  socket.on('matchFound', (data) => {
    console.log('üÜö Match found:', data);
    
    // Store initial game data
    gameData = {
      gameId: data.gameId,
      yourIndex: data.yourIndex,
      opponentName: data.opponentName,
      opponentWallet: data.opponentWallet,
      walletAddress: currentPlayer.walletAddress,
      playerName: currentPlayer.playerName,
      isGuestMode: currentPlayer.isGuestMode || false,
      background: data.background
    };
    
    // Show waiting screen with both players
    showWaitingScreen(data);
  });
  
  socket.on('gameCountdown', (countdown) => {
    console.log('‚è∞ Game countdown:', countdown);
    
    // Remove any existing countdown
    const existingCountdown = document.querySelector('.game-start-countdown');
    if (existingCountdown) {
      existingCountdown.remove();
    }
    
    if (countdown > 0) {
      // Create countdown element
      const countdownElement = document.createElement('div');
      countdownElement.className = 'game-start-countdown';
      countdownElement.textContent = countdown;
      document.body.appendChild(countdownElement);
      
      // Remove after 1 second
      setTimeout(() => {
        if (countdownElement.parentNode) {
          countdownElement.remove();
        }
      }, 1000);
    }
  });
  
  socket.on('gameStart', (data) => {
    console.log('üéÆ Game start event received:', data);
    
    // Remove any existing countdown
    const existingCountdown = document.querySelector('.game-start-countdown');
    if (existingCountdown) {
      existingCountdown.remove();
    }
    
    // Start the game
    handleGameStart(data);
  });
  
  socket.on('gameUpdate', (data) => {
    console.log('üîÑ Game update received:', data);
    handleGameUpdate(data);
  });
  
  socket.on('gameEnd', (data) => {
    console.log('üèÜ Game ended:', data);
    handleGameEnd(data);
  });
  
  socket.on('opponentEmoji', (data) => {
    console.log('üòÑ Opponent emoji:', data);
    showEmojiAnimation(data.emoji, false);
  });
  
  socket.on('opponentDisconnected', (data) => {
    console.log('üö™ Opponent disconnected:', data);
    alert('Opponent disconnected. You win!');
    audioManager.play('victory');
    showMainMenu();
  });
}

function updateConnectionStatus(status) {
  const statusElement = document.getElementById('connection-status');
  if (!statusElement) return;
  
  statusElement.className = `connection-status ${status}`;
  
  switch(status) {
    case 'connecting':
      statusElement.textContent = 'Connecting...';
      break;
    case 'connected':
      statusElement.textContent = 'Connected';
      break;
    case 'disconnected':
      statusElement.textContent = 'Disconnected';
      break;
    case 'error':
      statusElement.textContent = 'Connection Error';
      break;
  }
}

function showWaitingScreen(matchData = null) {
  console.log('‚è≥ Showing waiting screen with match data:', matchData);
  
  hideAllScreens();
  const waitingContainer = document.getElementById('waiting-container');
  
  if (matchData) {
    // Both players found - show VS screen
    const waitingScreen = waitingContainer.querySelector('.waiting-screen');
    waitingScreen.innerHTML = `
      <div class="waiting-split">
        <div class="waiting-left">
          <div class="waiting-player-icon">üë§</div>
          <div class="waiting-player-name">${matchData.yourIndex === 0 ? (gameData.playerName || 'You') : (matchData.opponentName || 'Opponent')}</div>
          <div class="waiting-status">Ready!</div>
        </div>
        
        <div class="vs-divider">VS</div>
        
        <div class="waiting-right">
          <div class="waiting-player-icon">üë§</div>
          <div class="waiting-player-name">${matchData.yourIndex === 1 ? (gameData.playerName || 'You') : (matchData.opponentName || 'Opponent')}</div>
          <div class="waiting-status">Ready!</div>
        </div>
      </div>
    `;
  }
  
  waitingContainer.style.display = 'flex';
}

// Game start handler
function handleGameStart(data) {
  console.log('üéÆ Game starting with data:', data);
  
  if (!data) {
    console.error('‚ùå No game data received');
    return;
  }

  // Data yapƒ±sƒ±nƒ± kontrol et ve d√ºzelt
  let gameStateData;
  if (data.gameState) {
    gameStateData = data.gameState;
  } else if (data.gameData) {
    gameStateData = data;
  } else {
    gameStateData = data;
  }

  console.log('üîß Game state data:', gameStateData);

  // Ensure we have the required data structure
  if (!gameStateData.gameData || !Array.isArray(gameStateData.gameData)) {
    console.error('‚ùå Invalid game data structure');
    return;
  }

  const yourIndex = data.yourIndex !== undefined ? data.yourIndex : 0;
  const opponentIndex = 1 - yourIndex;

  gameData = {
    gameId: data.gameId || 'unknown',
    yourIndex: yourIndex,
    opponentName: data.opponentName || 'Opponent',
    opponentWallet: data.opponentWallet || '',
    walletAddress: currentPlayer ? currentPlayer.walletAddress : '',
    playerName: currentPlayer ? currentPlayer.playerName : 'You',
    isGuestMode: currentPlayer ? currentPlayer.isGuestMode : false,
    yourTurn: gameStateData.currentTurn === yourIndex,
    you: gameStateData.gameData[yourIndex],
    opponent: gameStateData.gameData[opponentIndex],
    yourKryptomonTeam: gameStateData.gameData[yourIndex] ? gameStateData.gameData[yourIndex].kryptomonTeam : [],
    opponentKryptomonTeam: gameStateData.gameData[opponentIndex] ? gameStateData.gameData[opponentIndex].kryptomonTeam : [],
    currentTurn: gameStateData.currentTurn || 0,
    turnCount: gameStateData.turnCount || 1,
    background: gameStateData.background || data.background || 'background.png',
    hasUsedSwitch: gameStateData.gameData[yourIndex] ? gameStateData.gameData[yourIndex].hasUsedSwitch : false
  };

  console.log('‚úÖ Processed game data:', gameData);

  // Hide waiting screen and show game
  hideAllScreens();
  document.getElementById('game-container').style.display = 'block';

  // Set background
  setGameBackground(gameData.background);

  // Update player names in game
  updatePlayerNames();

  // Initialize Kryptomon displays
  updateKryptomonDisplay();
  updateGameUI();
  updateTurnInfo();

  console.log('üéÆ Game started successfully!');
}

function updateKryptomonDisplay() {
  if (!gameData || !gameData.yourKryptomonTeam || !gameData.opponentKryptomonTeam) {
    console.log('‚ö†Ô∏è Missing Kryptomon team data');
    return;
  }

  // Update player Kryptomon sprite
  const playerSprite = document.getElementById('player-kryptomon');
  if (playerSprite && gameData.yourKryptomonTeam[gameData.you.activeKryptomon]) {
    playerSprite.src = gameData.yourKryptomonTeam[gameData.you.activeKryptomon].image;
    playerSprite.alt = gameData.yourKryptomonTeam[gameData.you.activeKryptomon].name;
  }

  // Update enemy Kryptomon sprite
  const enemySprite = document.getElementById('enemy-kryptomon');
  if (enemySprite && gameData.opponentKryptomonTeam[gameData.opponent.activeKryptomon]) {
    enemySprite.src = gameData.opponentKryptomonTeam[gameData.opponent.activeKryptomon].image;
    enemySprite.alt = gameData.opponentKryptomonTeam[gameData.opponent.activeKryptomon].name;
  }

  // Update Kryptomon team slots
  updateKryptomonTeamSlots();
}

function updateKryptomonTeamSlots() {
  // Update player team slots
  const playerTeamSlots = document.querySelectorAll('.kryptomon-team.left .kryptomon-slot');
  if (gameData.yourKryptomonTeam) {
    playerTeamSlots.forEach((slot, index) => {
      const img = slot.querySelector('img');
      if (gameData.yourKryptomonTeam[index] && img) {
        img.src = gameData.yourKryptomonTeam[index].image;
        slot.classList.toggle('active', index === gameData.you.activeKryptomon);
        
        // Kryptomon √∂l√º m√º kontrol et
        const currentHealth = gameData.you.activeKryptomon === index ? gameData.you.health : gameData.yourKryptomonTeam[index].health || 100;
        slot.classList.toggle('dead', currentHealth <= 0);
      }
    });
  }

  // Update opponent team slots
  const opponentTeamSlots = document.querySelectorAll('.kryptomon-team.right .kryptomon-slot');
  if (gameData.opponentKryptomonTeam) {
    opponentTeamSlots.forEach((slot, index) => {
      const img = slot.querySelector('img');
      if (gameData.opponentKryptomonTeam[index] && img) {
        img.src = gameData.opponentKryptomonTeam[index].image;
        slot.classList.toggle('active', index === gameData.opponent.activeKryptomon);
        
        // Kryptomon √∂l√º m√º kontrol et
        const currentHealth = gameData.opponent.activeKryptomon === index ? gameData.opponent.health : gameData.opponentKryptomonTeam[index].health || 100;
        slot.classList.toggle('dead', currentHealth <= 0);
      }
    });
  }
}

// Game UI updates
function updateGameUI() {
  if (!gameData) return;
  
  // Update health bars
  updateHealthBar('your', gameData.you.health, gameData.you.maxHealth);
  updateHealthBar('enemy', gameData.opponent.health, gameData.opponent.maxHealth);
  
  // Update mana displays - sadece rakam
  updateManaDisplay('your', gameData.you.mana);
  updateManaDisplay('enemy', gameData.opponent.mana);
  
  // Update HP images
  const yourHpImage = document.getElementById('your-hp-image');
  const enemyHpImage = document.getElementById('enemy-hp-image');
  
  if (yourHpImage && gameData.yourKryptomonTeam[gameData.you.activeKryptomon]) {
    yourHpImage.src = gameData.yourKryptomonTeam[gameData.you.activeKryptomon].image;
  }
  
  if (enemyHpImage && gameData.opponentKryptomonTeam[gameData.opponent.activeKryptomon]) {
    enemyHpImage.src = gameData.opponentKryptomonTeam[gameData.opponent.activeKryptomon].image;
  }
  
  // Update control buttons
  updateControlButtons();
  
  // Update team slots
  updateKryptomonTeamSlots();
}

function updateHealthBar(target, health, maxHealth) {
  const percentage = Math.max(0, (health / maxHealth) * 100);
  const healthText = document.getElementById(`${target}-hp-text`);
  const healthFill = document.getElementById(`${target}-hp-fill`);
  
  if (healthText) {
    healthText.textContent = `${health}/${maxHealth}`;
  }
  
  if (healthFill) {
    healthFill.style.width = `${percentage}%`;
  }
}

function updateManaDisplay(target, mana) {
  const manaText = document.getElementById(`${target}-mana-text`);
  
  if (manaText) {
    manaText.textContent = mana.toString();
  }
}

function updateControlButtons() {
  if (!gameData) return;
  
  const attackBtn = document.getElementById('attack-btn');
  const skillBtn = document.getElementById('skill-btn');
  const ultimateBtn = document.getElementById('ultimate-btn');
  const defendBtn = document.getElementById('defend-btn');
  
  const isYourTurn = gameData.yourTurn;
  const mana = gameData.you.mana;
  const defenseCooldown = gameData.you.defenseCooldown || 0;
  
  // Enable/disable buttons based on turn and mana
  if (attackBtn) attackBtn.disabled = !isYourTurn;
  if (skillBtn) skillBtn.disabled = !isYourTurn || mana < 2;
  if (ultimateBtn) ultimateBtn.disabled = !isYourTurn || mana < 6;
  if (defendBtn) defendBtn.disabled = !isYourTurn || defenseCooldown > 0;
}

function updateTurnInfo() {
  if (!gameData) return;
  
  const turnIndicator = document.getElementById('turn-indicator');
  const turnTimer = document.getElementById('turn-timer');
  
  if (turnIndicator) {
    turnIndicator.textContent = gameData.yourTurn ? 'Your Turn' : 'Opponent\'s Turn';
  }
  
  // Start turn timer if it's your turn
  if (gameData.yourTurn) {
    startTurnTimer();
  } else {
    clearTurnTimer();
  }
}

function startTurnTimer() {
  clearTurnTimer();
  
  let timeLeft = 30;
  const timerElement = document.getElementById('turn-timer');
  
  turnTimer = setInterval(() => {
    timeLeft--;
    if (timerElement) {
      timerElement.textContent = `${timeLeft}s`;
    }
    
    if (timeLeft <= 0) {
      clearTurnTimer();
      // Send timeout to server
      if (socket && gameData && gameData.yourTurn) {
        socket.emit('turnTimeout', {});
      }
    }
  }, 1000);
}

function clearTurnTimer() {
  if (turnTimer) {
    clearInterval(turnTimer);
    turnTimer = null;
  }
}

// Player move function
function playerMove(move) {
  if (!socket || !gameData || !gameData.yourTurn) {
    console.log('‚ùå Cannot make move: not your turn or no connection');
    return;
  }
  
  console.log('üéØ Making move:', move);
  
  // Play sound effect
  audioManager.play(move === 'attack' ? 'bite' : move);
  
  // Add animation to player Kryptomon
  const playerSprite = document.getElementById('player-kryptomon');
  if (playerSprite) {
    playerSprite.classList.add(`${move}-animation`);
    setTimeout(() => {
      playerSprite.classList.remove(`${move}-animation`);
    }, move === 'ultimate' ? 1200 : (move === 'skill' ? 800 : 600));
  }
  
  socket.emit('playerMove', {
    move: move
  });
  
  // Disable controls temporarily
  updateControlButtons();
}

// Kryptomon switching
function switchKryptomon(index) {
  if (!socket || !gameData || !gameData.yourTurn || gameData.hasUsedSwitch) {
    console.log('‚ùå Cannot switch: not your turn, no connection, or already switched');
    return;
  }
  
  if (index === gameData.you.activeKryptomon) {
    console.log('‚ùå Already active Kryptomon');
    return;
  }
  
  // Check if target Kryptomon is alive
  const targetKryptomon = gameData.yourKryptomonTeam[index];
  if (!targetKryptomon || (targetKryptomon.health !== undefined && targetKryptomon.health <= 0)) {
    console.log('‚ùå Cannot switch to dead Kryptomon');
    return;
  }
  
  console.log('üîÑ Switching to Kryptomon:', index);
  
  // Play switch sound
  audioManager.play('switch');
  
  // Add switch animation
  const playerSprite = document.getElementById('player-kryptomon');
  if (playerSprite) {
    playerSprite.classList.add('kryptomon-switch-animation');
    
    setTimeout(() => {
      // Change sprite after half animation
      playerSprite.src = gameData.yourKryptomonTeam[index].image;
      playerSprite.classList.remove('kryptomon-switch-animation');
      playerSprite.classList.add('slide-in');
      
      setTimeout(() => {
        playerSprite.classList.remove('slide-in');
      }, 1000);
    }, 500);
  }
  
  socket.emit('playerMove', {
    move: 'switch',
    activeKryptomon: index
  });
}

// Game update handler
function handleGameUpdate(data) {
  console.log('üîÑ Processing game update:', data);
  
  if (!data.gameState) return;
  
  const yourIndex = gameData.yourIndex;
  const opponentIndex = 1 - yourIndex;
  
  // Update game data
  gameData.you = data.gameState.gameData[yourIndex];
  gameData.opponent = data.gameState.gameData[opponentIndex];
  gameData.yourTurn = data.gameState.currentTurn === yourIndex;
  gameData.currentTurn = data.gameState.currentTurn;
  gameData.turnCount = data.gameState.turnCount;
  gameData.hasUsedSwitch = gameData.you.hasUsedSwitch;
  
  // Handle move result
  if (data.lastMoveResult) {
    handleMoveResult(data.lastMoveResult);
  }
  
  // Check for automatic Kryptomon switching (when current dies)
  if (gameData.you.health <= 0) {
    handleKryptomonDeath(true);
  }
  if (gameData.opponent.health <= 0) {
    handleKryptomonDeath(false);
  }
  
  // Update UI
  updateGameUI();
  updateTurnInfo();
}

// Handle Kryptomon death and auto-switch
function handleKryptomonDeath(isYours) {
  const teamData = isYours ? gameData.yourKryptomonTeam : gameData.opponentKryptomonTeam;
  const playerData = isYours ? gameData.you : gameData.opponent;
  
  // Mark current Kryptomon as dead
  if (teamData[playerData.activeKryptomon]) {
    teamData[playerData.activeKryptomon].health = 0;
  }
  
  // Find next alive Kryptomon
  let nextAliveIndex = -1;
  for (let i = 0; i < teamData.length; i++) {
    if (i !== playerData.activeKryptomon && 
        teamData[i] && 
        (!teamData[i].health || teamData[i].health > 0)) {
      nextAliveIndex = i;
      break;
    }
  }
  
  if (nextAliveIndex !== -1) {
    // Auto-switch to next alive Kryptomon
    if (isYours) {
      console.log('üîÑ Auto-switching your Kryptomon to index:', nextAliveIndex);
      // Don't send switch command, let server handle it
    } else {
      console.log('üîÑ Opponent auto-switching to index:', nextAliveIndex);
    }
    
    // Update display immediately
    playerData.activeKryptomon = nextAliveIndex;
    const newStats = teamData[nextAliveIndex].stats;
    if (newStats) {
      playerData.health = newStats.health;
      playerData.maxHealth = newStats.health;
      playerData.attack = newStats.attack;
      playerData.defense = newStats.defense;
    }
    
    // Update sprites
    updateKryptomonDisplay();
  } else {
    // No more Kryptomon alive - game should end
    console.log('üíÄ No more alive Kryptomon for', isYours ? 'you' : 'opponent');
  }
}

// Handle move result effects
function handleMoveResult(moveResult) {
  if (!moveResult) return;
  
  console.log('‚ú® Processing move result:', moveResult);
  
  // Determine target sprites
  const attackerSprite = moveResult.attackerIndex === gameData.yourIndex ? 
    document.getElementById('player-kryptomon') : 
    document.getElementById('enemy-kryptomon');
  
  const targetSprite = moveResult.targetIndex === gameData.yourIndex ? 
    document.getElementById('player-kryptomon') : 
    document.getElementById('enemy-kryptomon');
  
  // Show damage text
  if (moveResult.damage > 0) {
    showDamageText(targetSprite, moveResult.damage, moveResult.isCritical);
  }
  
  // Show shield effect on attacker (defender) if defense was activated
  if (moveResult.shieldEffect && moveResult.moveType === 'defend') {
    showShieldEffect(attackerSprite);
  }
  
  // Show ultimate effect on target
  if (moveResult.ultimateEffect) {
    showUltimateEffect(targetSprite);
  }
  
  // Handle Kryptomon switching animation
  if (moveResult.kryptomonSwitched && moveResult.newActiveKryptomon) {
    const switcherSprite = moveResult.attackerIndex === gameData.yourIndex ? 
      document.getElementById('player-kryptomon') : 
      document.getElementById('enemy-kryptomon');
    
    if (switcherSprite) {
      audioManager.play('switch');
      switcherSprite.classList.add('kryptomon-switch-animation');
      
      setTimeout(() => {
        switcherSprite.src = moveResult.newActiveKryptomon.image;
        switcherSprite.classList.remove('kryptomon-switch-animation');
        switcherSprite.classList.add('slide-in');
        
        setTimeout(() => {
          switcherSprite.classList.remove('slide-in');
        }, 1000);
      }, 500);
    }
  }
}

// Show damage text
function showDamageText(targetElement, damage, isCritical = false) {
  if (!targetElement) return;
  
  const damageText = document.createElement('div');
  damageText.className = `damage-text ${isCritical ? 'critical' : ''}`;
  damageText.textContent = isCritical ? `CRITICAL ${damage}!` : damage;
  
  const rect = targetElement.getBoundingClientRect();
  damageText.style.position = 'fixed';
  damageText.style.left = rect.left + rect.width / 2 + 'px';
  damageText.style.top = rect.top + 'px';
  damageText.style.transform = 'translateX(-50%)';
  damageText.style.zIndex = '1000';
  
  document.body.appendChild(damageText);
  
  setTimeout(() => {
    if (damageText.parentNode) {
      damageText.remove();
    }
  }, 1500);
}

// Show shield effect
function showShieldEffect(targetElement) {
  if (!targetElement) return;
  
  const shieldEffect = document.createElement('div');
  shieldEffect.className = 'shield-effect';
  
  const rect = targetElement.getBoundingClientRect();
  shieldEffect.style.position = 'fixed';
  shieldEffect.style.left = rect.left + rect.width / 2 + 'px';
  shieldEffect.style.top = rect.top + rect.height / 2 + 'px';
  shieldEffect.style.zIndex = '200';
  
  document.body.appendChild(shieldEffect);
  
  setTimeout(() => {
    if (shieldEffect.parentNode) {
      shieldEffect.remove();
    }
  }, 800);
}

// Show ultimate effect
function showUltimateEffect(targetElement) {
  if (!targetElement) return;
  
  const ultimateEffect = document.createElement('div');
  ultimateEffect.className = 'ultimate-effect';
  
  const rect = targetElement.getBoundingClientRect();
  ultimateEffect.style.position = 'fixed';
  ultimateEffect.style.left = rect.left + rect.width / 2 + 'px';
  ultimateEffect.style.top = rect.top + rect.height / 2 + 'px';
  ultimateEffect.style.zIndex = '200';
  
  document.body.appendChild(ultimateEffect);
  
  setTimeout(() => {
    if (ultimateEffect.parentNode) {
      ultimateEffect.remove();
    }
  }, 1500);
}

// Game end handler
function handleGameEnd(data) {
  console.log('üèÜ Game ended:', data);
  
  clearTurnTimer();
  
  // Play victory sound
  audioManager.play('victory');
  
  let message = 'Game Over!';
  if (data.winner !== null) {
    const isYouWinner = data.winner === gameData.yourIndex;
    message = isYouWinner ? 'üéâ Victory!' : 'üíÄ Defeat!';
  } else {
    message = 'ü§ù Draw!';
  }
  
  if (data.surrendered) {
    const surrenderer = data.surrenderer === gameData.yourIndex ? 'You' : 'Opponent';
    message = `${surrenderer} surrendered!`;
  }
  
  setTimeout(() => {
    alert(message);
    showMainMenu();
  }, 2000);
}

// Utility functions
function showMainMenu() {
  hideAllScreens();
  document.getElementById('player-name-container').style.display = 'flex';
  
  // Reset game data
  gameData = null;
  currentPlayer = null;
  selectedNFTs = [];
  
  // Disconnect socket
  if (socket) {
    socket.disconnect();
    socket = null;
  }
}

function surrender() {
  if (!socket || !gameData) return;
  
  if (confirm('Are you sure you want to surrender?')) {
    socket.emit('surrender');
  }
}

function toggleEmojiPanel() {
  const emojiPanel = document.getElementById('emoji-panel');
  if (emojiPanel.style.display === 'block') {
    emojiPanel.style.display = 'none';
  } else {
    emojiPanel.style.display = 'block';
  }
}

function sendEmoji(emoji) {
  if (!socket || !gameData) return;
  
  socket.emit('sendEmoji', { emoji: emoji });
  
  // Show emoji on your side
  showEmojiAnimation(emoji, true);
  
  // Hide emoji panel
  document.getElementById('emoji-panel').style.display = 'none';
}

function showEmojiAnimation(emoji, isYours) {
  const emojiElement = document.createElement('div');
  emojiElement.className = 'emoji-animation';
  emojiElement.textContent = emoji;
  
  // Position based on side
  const battleArena = document.querySelector('.battle-arena');
  if (battleArena) {
    const rect = battleArena.getBoundingClientRect();
    emojiElement.style.position = 'fixed';
    emojiElement.style.left = (isYours ? rect.left + 100 : rect.right - 100) + 'px';
    emojiElement.style.top = rect.top + rect.height / 2 + 'px';
    emojiElement.style.zIndex = '1000';
    
    document.body.appendChild(emojiElement);
    
    setTimeout(() => {
      if (emojiElement.parentNode) {
        emojiElement.remove();
      }
    }, 2000);
  }
}
</script>

</body>
</html>
